<apex:page standardController="Flosum__Patch__c" extensions="Flosum.PatchImpactAnalysisController" sidebar="false" doctype="html-5.0"  cache="false">
    <c:TrackPanel />
    <c:Wait />
    <apex:slds />

    <apex:stylesheet value="{!URLFOR($Resource.Flosum__bootstrapiso)}"/>

    <apex:includeScript value="{!URLFOR($Resource.Flosum__zipp,'res/ga.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__zipp,'res/js/zip.js')}"/>
    <apex:includeScript value="{!$Resource.Flosum__xmltojson}"/>
    <apex:includeScript value="{!$Resource.Flosum__X2JS}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__ContentEditor, 'beauty/forMatXML.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__jszipmaster, 'jszip-master/dist/jszip.js')}"/>

    <apex:stylesheet value="{!$Resource.Flosum__DiffCSS}"/>
    <script src="{!$Resource.DiffJS}"></script>

    <apex:includeScript value="{!URLFOR($Resource.Flosum__jszipmaster,'jszip-master/flosumsf/flosumsf1.6.0.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__jszipmaster, 'jszip-master/dist/jszip.min.js')}"/>
    <!--        added resources      -->

    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/jquery-2.1.4.min.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/angular.min.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/difflib.js')}"/>

    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/angular-base64.min.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/deep-diff-0.3.3.min.js')}"/>
    <script src="{!$Resource.Flosum__X2JS}"></script>

    <!-- for new panel -->
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/bootstrap.min.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/angular-route.min.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/angular-aria.min.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/angular-messages.min.js')}"/>

    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/pako.min.js')}"/>

    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/angular-modal-service.min.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/editor.js')}"/>
    <apex:stylesheet value="{!URLFOR($Resource.Flosum__Merge, 'Merge/css/style.css')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/bkup.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/fullbkup.js')}"/>


    <apex:stylesheet value="{!URLFOR($Resource.Flosum__Merge, 'Merge/css/bootstrapSF.min.css')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/jquery.min.js')}"/>

    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/jquery-ui.min.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/jquery.ui-contextmenu.min.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/diffxmllib.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/codemirror.min.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/xml.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/searchcursor.min.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/mergely.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/parser.js')}"/>

    <apex:stylesheet value="{!URLFOR($Resource.Flosum__Merge, 'Merge/css/jquery-ui.css')}"/>
    <apex:stylesheet value="{!URLFOR($Resource.Flosum__Merge, 'Merge/css/mergely.css')}"/>
    <apex:stylesheet value="{!URLFOR($Resource.Flosum__Merge, 'Merge/css/codemirror.css')}"/>
    <apex:stylesheet value="{!URLFOR($Resource.Flosum__Merge, 'Merge/css/dialog.css')}"/>

    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/diffutils.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/dialog.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/search.js')}"/>


    <style type="text/css" media="screen">
        .activeTab {
            background-color: #236FBD;
            color: white;
            tab-color: yellow;
            background-image: none
        }

        .inactiveTab {
            background-color: white;
            color: black;
            background-image: none
        }

        body .bPageTitle .ptBody h1.noSecondHeader {
            color: #FFF;
        }

        .pagination {
            padding: 1%;
        }

        div .pagination {
            text-align: center;
        }

        td .dataCell label {
            font-weight: normal;
        }

        .pagination input {
            margin-left: 4px;
        }

        hr.pBlockDescription {
            margin-top: 0%;
            border-bottom: 1px solid #DBDBDB;
        }

        tr {
            display: table-row;
            vertical-align: inherit;
            border-color: inherit;
        }

        .EmpyBlock {
            height: 18px;
        }

        .bundle_error_msg {
            display: none;
            padding: 5px;
            color: #FF4500;
            background-color: #ffffb3;
            text-align: center;
            font-size: 16px;
            width: 100%;
        }

        .teamSelector {
            display: block;
            position: relative;
            font-size: 1.8em;
            overflow: hidden;
            padding-right: 1.2em;
            padding-left: 2em;
            width: 100%;
            white-space: nowrap;
            cursor: pointer;
        }

        .virtualRepeatdemoVerticalUsage .md-virtual-repeat-container .md-virtual-repeat-offsetter div {
            padding-left: initial;
            padding-top: initial;
            vertical-align: sub;
        }

        .virtualRepeatVerticalUsageXml .md-virtual-repeat-container .md-virtual-repeat-offsetter div {
            padding-left: initial;
        }

        .virtualRepeatVerticalUsageXml .header .headerTitle {
            font-weight: bolder;
            font-size: 14px;
            width: 400px;
            float: left;
            text-align: center;
        }

        .virtualRepeatVerticalUsageXml .header .headerButtonPlaceholder {
            width: 400px;
            float: left;
            text-align: center;
        }

        .virtualRepeatVerticalUsageXml .headerButton {
            width: 700px;
            float: left;
            text-align: center;
        }

        /************* ReWrite MODAL STYLES  *************/
        /*
                .modal-backdrop.in {
                    opacity: 0;
                }
                 .modal.fade .modal-dialog, .modal.in .modal-dialog {
                    position: fixed;
                    top: 20%;
                    left: 35%;
                      transform: translateY(-1000px);
                    transition: 0.1s;
                }
                .modal-open, .modal-open .navbar-fixed-top {
                       overflow: hidden;
                    padding-right: 0 !important;
                }
        */
        .bootstrap-iso .modal-backdrop.in {
            opacity: 0;
        }

        .bootstrap-iso .modal.fade .modal-dialog, .modal.in .modal-dialog {
            position: fixed;
            top: 30%;
            left: 30%;
        / / transform: translateY(- 1000 px);
            transition: 0.1s;
        }

        .bootstrap-iso .modal-open, .modal-open .navbar-fixed-top {
            overflow: hidden;
            padding-right: 0 !important;
        }


        #ruler {
            visibility: hidden;
            white-space: nowrap;
            font-family: monospace;
            font-size: 12px;
        }

        #ruler-xml {
            visibility: hidden;
            white-space: nowrap;
            font-family: monospace;
            font-size: 12px;
        }

        .btn-warning:hover, .btn-warning:focus, .btn-warning:active, .btn-warning.active, .open > .dropdown-toggle.btn-warning {
            color: #000;
        }

        .btn-success:hover, .btn-success:focus, .btn-success:active, .btn-success.active, .open > .dropdown-toggle.btn-success {
            color: #000;
        }

        /********************   SLDS   ************************/
        .boxPadding {
            padding: .5rem !important;
        }

        .topMargin {
            margin-top: 5px !important;
        }



        .paneltopMargin {
            margin-top: 10px !important;
        }

        .paddingClass td, .paddingClass th {
            padding: 0rem !important;
            padding-left: 1.5rem !important;
        }

        .slds-scope .slds-section.slds-is-open .slds-section__content {
            padding-top: 0rem !important;
        }

        .btnPanelMargin {
            margin-top: -8px !important;
            margin-bottom: -8px !important;
        }

        .leftMargin {
            margin-left: 15px !important;
        }

        .btnBoredrClr {
            border-color: silver !important;
        }
    </style>

    <style type="text/css" media="screen">
        .grid {
            display: flex;
        }

        .title {
            flex: 1;
            height: 20px;
            text-align: center;
        }

        /************* ReWrite MODAL STYLES  *************/
        .bootstrap-iso .modal-backdrop.in {
            opacity: 0;
        }

        .bootstrap-iso .modal.fade .modal-dialog, .modal.in .modal-dialog {
            position: fixed;
            top: 30%;
            left: 30%;
            transition: 0.1s;
        }

        .bootstrap-iso .modal-open, .modal-open .navbar-fixed-top {
            overflow: hidden;
            padding-right: 0 !important;
        }

        /* Center the loader */
        .spinner {
            position: absolute;
            display: block;
            left: 54%;
            top: 55%;
            z-index: 1000;
            width: 150px;
            height: 150px;
            margin: -75px 0 0 -75px;
            border: 8px solid #f3f3f3;
            border-radius: 50%;
            border-top: 4px solid #646464;
            border-right: 4px solid #e6e6e6;
            border-left: 4px solid #e6e6e6;
            border-bottom: 4px solid #646464;
            width: 60px;
            height: 60px;
            -webkit-animation: spin 2s linear infinite;
            animation: spin 2s linear infinite;
        }


        @-webkit-keyframes spin {
            0% {
                -webkit-transform: rotate(0deg);
            }
            100% {
                -webkit-transform: rotate(360deg);
            }
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        /* Add animation to "page content" */
        .animate-bottom {
            position: relative;
            -webkit-animation-name: animatebottom;
            -webkit-animation-duration: 1s;
            animation-name: animatebottom;
            animation-duration: 1s
        }

        @-webkit-keyframes animatebottom {
            from {
                bottom: -100px;
                opacity: 0
            }
            to {
                bottom: 0px;
                opacity: 1
            }
        }

        @keyframes animatebottom {
            from {
                bottom: -100px;
                opacity: 0
            }
            to {
                bottom: 0;
                opacity: 1
            }
        }

        .tab {
            overflow: hidden;
            border: 1px solid #ccc;
            background-color: #f1f1f1 !important;
        }

        .tab button {
            background-color: inherit !important;
            float: left;
            border: none;
            outline: none;
            font-size: 12px;
            padding: 5px 8px;
            background: none !important;
        }

        .tab button:hover {
            background-color: #ddd !important;
        }

        .tab button.active {
            background-color: #b3b3b3 !important;
        }

        .diff tbody th {
            padding-left: 0 !important;
        }

        .message {
            list-style-type: none;
        }

        .message .messageText {
            color: white !important;
        }

        .message .messageText h4 {
            color: white !important;
        }

        .message span {
            color: white !important;
        }

        /*.customMessage {
            margin-left: 0px !important;
            margin-top: 0px !important;
            opacity: 1 !important;
            width: 100%;
            font-size: 13px;
            border: 0px;
            padding-left: 10px;
        }*/

        html.gr__c_cs23_visual_force_com.ext-strict {
            font-size: 16px;
        }

    </style>

    <style>

        [ng\:cloak], [ng-cloak], [data-ng-cloak], [x-ng-cloak], .ng-cloak, .x-ng-cloak {
            display: none !important;
        }

        .red {
            background-color: rgba(255, 158, 158, 0.65);
        }

        .yellow {
            background-color: rgba(252, 252, 164, 1);
        }

        .diff tbody th {
            padding-left: 0 !important;
        }

        .message .messageText {
            color: white !important;
        }

        .message .messageText h4 {
            color: white !important;
        }

        .errorMessageLi span {
            color: white !important;
        }

        .lbcls {
            font-weight: 700 !important;
        }

        .customMessage * {
            color: #fff !important
        }

        .customMessage {
            margin: 0px !important;
            opacity: 1 !important;
            width: 100%;
            font-size: 13px;
            border: 0px;
            padding-left: 10px;
        }


        .legendulclass {
            list-style: none;
            margin: 0;
            padding: 0;
            margin-top: 10px !important;
        }

        .input-color {
            position: relative;
        }

        .input-color input {
            padding-left: 20px;
            margin-bottom: 10px;
        }

        .color-box {
            width: 12px;
            height: 12px;
            display: inline-block;
            position: absolute;
            left: 5px;
            top: 5px;
            border: 1px solid #000;
        }
    </style>

    <div class="slds-scope">
        <apex:form styleClass="slds-form--stacked">
            <apex:actionfunction action="{!showMessage}" reRender="CTPmg" name="showMessage"
                                 onComplete="hide();overridePageMessages();">
                <apex:param assignTo="{!CPT_Message}" value="" name="newstr"/>
            </apex:actionfunction>
            <apex:actionfunction action="{!updateAttachments}" name="uploadAttachments"
                                 onComplete="processResults('{!errorCode}');">
                <apex:param assignTo="{!uploadJson}" value="" name="uploadJson"/>
            </apex:actionfunction>

            <apex:pagemessages id="CTPmg"/>
            <apex:pagemessages id="msg"/>

            <div class="slds-page-header">
                <div class="slds-media">
                    <h1 class="slds-page-header__title slds-truncate slds-align-middle" title="Impact Analysis">Impact
                        Analysis</h1>
                </div>

            </div>
            <!--Angular-->
            <div ng-app="ImpactAnalysisPagination">
                <div ng-controller="ImpactAnalysisPaginationController" id="ImpactAnalysysControllerId">
                    <div class="ng-cloak">

                        <fieldset class="slds-box slds-theme--default">
                            <apex:outputPanel html-ng-show="CommitStep == 0" layout="block"
                                              styleClass="slds-box slds-theme--default slds-container boxPadding">
                            <apex:outputPanel layout="block" id="tbl" >
                                <apex:outputPanel layout="block" id="transfertobranch">
                                    <div class="slds-float--right" role="group">
                                        <apex:commandButton value="Impact Analysis"
                                                            onClick="startRetrieval(); show(); return false;"
                                                            rendered="{!authDetails != null && authDetails.isSuccess}"
                                                            reRender="CTPmg,tbl"
                                                            styleClass="btn slds-button slds-button_neutral" />
                                        <apex:commandbutton styleClass="slds-button slds-button_neutral" value="Cancel"
                                                            action="{!back}" reRender="msg" id="button2"/>
                                        <apex:commandButton styleClass="slds-button slds-button_neutral" value="Save"
                                                            action="{!refresh}" onClick="saveChanges();"
                                                            onComplete="overridePageMessages();" reRender="CTPmg"
                                                            rendered="{!authDetails != null && authDetails.isSuccess}"
                                                            id="button1" html-ng-disabled="saveButton"/>
                                    </div>
                                    <apex:outputPanel styleClass="slds-form-element slds-size--4-of-12" layout="block">
                                        <apex:outputLabel styleClass="slds-form-element__label slds-text-heading_regular lbcls"
                                                value="{!$ObjectType.Flosum__Patch__c.fields.Name.Label}"/>
                                        <div class="slds-form-element__control">
                                            <apex:outputLabel style="background-color: #eef1f6"
                                                              styleClass="slds-input slds-text-heading_regular"
                                                              value="{!Flosum__Patch__c.Name}"/>
                                        </div>
                                    </apex:outputPanel>
                                    <apex:outputPanel styleClass="slds-form-element slds-size--4-of-12" layout="block"
                                                      rendered="{!AND(patchId != null,patchId != '')}">
                                        <apex:outputLabel styleClass="slds-form-element__label slds-text-heading_regular lbcls"
                                                value="Target Salesforce Organisation"/>
                                        <div class="slds-form-element__control">
                                            <div class="slds-select_container">
                                                <apex:selectList styleClass="slds-select slds-text-heading_regular disableitem"
                                                        id="selectedOrg" size="1" value="{!selectedOrg}">
                                                    <apex:selectOptions value="{!targetOrgOptions}"/>
                                                    <apex:actionSupport event="onchange" action="{!onSelectOrg}"
                                                                        rerender="CTPmg,tbl" onsubmit="show();"
                                                                        oncomplete="hide();overridePageMessages();"/>
                                                </apex:selectList>
                                            </div>
                                        </div>
                                    </apex:outputPanel>
                                    <apex:outputPanel styleClass="slds-form-element slds-size--4-of-12" layout="block"
                                                      rendered="{!AND(patchId != null,patchId != '')}">
                                        <apex:outputLabel styleClass="slds-form-element__label slds-text-heading_regular lbcls"
                                                value="View Option"/>
                                        <div class="slds-form-element__control">
                                            <div class="slds-select_container">
                                                <apex:selectList styleClass="slds-select slds-text-heading_regular disableitem"
                                                        id="selectedView" size="1" value="{!selectedView}"
                                                        onchange="filterPatchItemsForPagination();">
                                                    <apex:selectOptions value="{!viewOptions}"/>
                                                </apex:selectList>
                                            </div>
                                        </div>
                                    </apex:outputPanel>
                                </apex:outputPanel>
                            </apex:outputPanel>

                            <div html-ng-show="isLoading" class="loading-indicator" ng-cloak="" id="spinner"/>
                            <script type="text/ng-template" id="customL.html">
                                <div aria-hidden="false" role="dialog" class="slds-modal slds-fade-in-close"
                                     style="opacity:0.9; visibility: visible;" id="idDialog">
                                    <div class="slds-modal__container" style="width:55%">

                                        <div class="slds-modal__content">
                                            <div class="slds-modal__header" style="background-color: #d8dde6;">
                                                <button class="slds-button slds-button--icon-inverse slds-modal__close"
                                                        ng-click="close(false)" data-dismiss="modal" aria-hidden="true">
                                                    &times;
                                                </button>
                                                <h2 class="slds-text-heading--medium">Resolving conflict</h2>
                                            </div>
                                            <div class="slds-modal__body"
                                                 style="padding-left: 20px;padding-right: 20px;">
                                                <p>The components with types Document, StaticResource are not editable
                                                    in current version of Flosum.</p>
                                                <p> Choose how to resolve the conflict:</p>
                                            </div>
                                            <div style="padding-left: 20px;">
                                                <div ng-init="question.selected = 1">
                                                    <label data-ng-repeat="choice in question.choices">
                                                        <input type="radio" name="response"
                                                               data-ng-model="question.selected"
                                                               data-ng-value="{{choice.id}}"/>
                                                        {{choice.text}}
                                                        <br/>
                                                    </label>
                                                </div>
                                            </div>
                                            <div class="slds-truncate slds-th__action slds-th__action_form"
                                                 style="padding-left: 20px;padding-right: 20px;">
                                                <label class="slds-checkbox">
                                                    <input type="checkbox" class="slds-input psli" ng-model="alwaysDo"/>
                                                    <span class="slds-checkbox_faux"></span>
                                                    <span class="slds-assistive-text"></span>
                                                    <span class="slds-form-element__label">Apply the same action for all similar components</span>
                                                </label>
                                            </div>
                                            <div class="modal-footer" style="text-align:center;padding-bottom: 20px;">
                                                <button type="button" ng-click="close(false)" data-dismiss="modal"
                                                        class="btn slds-button slds-button_neutral">Cancel
                                                </button>
                                                <button type="button" ng-click="close(true)" data-dismiss="modal"
                                                        class="btn slds-button slds-button_neutral">Apply
                                                </button>
                                            </div>

                                        </div>
                                    </div>
                                </div>
                            </script>

                            <script type="text/ng-template" id="customC.html">
                                <div class="bootstrap-iso modal" id="modalDialog1"
                                     style="transition: 0s; padding-right: 0px;">
                                    <div class="bootstrap-iso modal-dialog">
                                        <div class="bootstrap-iso modal-content">
                                            <div class="bootstrap-iso modal-header">
                                                <button type="button" class="close" ng-click="close(false)"
                                                        data-dismiss="modal" aria-hidden="true">&times;
                                                </button>
                                                <h4 class="modal-title">Resolving conflict</h4>
                                            </div>
                                            <div class="bootstrap-iso modal-body">
                                                <p>The components with types Document, StaticResource are not editable
                                                    in current version of Flosum.</p>
                                                <p> Choose how to resolve the conflict:</p>
                                            </div>
                                            <div style="padding-left: 20px;">
                                                <div ng-init="question.selected = 1">
                                                    <label data-ng-repeat="choice in question.choices">
                                                        <input type="radio" name="response"
                                                               data-ng-model="question.selected"
                                                               data-ng-value="{{choice.id}}"/>
                                                        {{choice.text}}
                                                        <br/>
                                                    </label>
                                                </div>
                                            </div>
                                            <div style="padding-left: 20px;">
                                                <input type="checkbox" class="psli" ng-model="alwaysDo">Apply the same
                                                action for all similar components</input>
                                            </div>
                                            <div class="bootstrap-iso modal-footer" style="text-align:center;">
                                                <button type="button" ng-click="close(false)" class="btn btn-warning"
                                                        data-dismiss="modal">Cancel
                                                </button>
                                                <button type="button" ng-click="close(true)" class="btn btn-success"
                                                        data-dismiss="modal">Apply
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </script>


                                <apex:outputPanel layout="block" id="tb" styleClass="slds-m-top_small"
                                                  html-ng-show="paginationList.length > 0 ">
                                    <!--legend-->
                                    <ul class="legendulclass">
                                        <li>
                                            <div class="input-color">
                                                <input type="text"
                                                       value="Components exist in the deployment & target org, but are different."
                                                       readonly="true" style="border:0;width:100%;"/>
                                                <div class="color-box yellow"></div>
                                            </div>
                                        </li>
                                        <li>
                                            <div class="input-color">
                                                <input type="text"
                                                       value="Components exist in the deployment but don’t exist in the target org."
                                                       readonly="true" style="border:0;width:100%;"/>
                                                <div class="color-box red"></div>
                                            </div>
                                        </li>
                                        <li>
                                            <div class="input-color">
                                                <input type="text"
                                                       value="Components exist in the deployment & target org, but they are identical."
                                                       readonly="true" style="border:0;width:100%;"/>
                                                <div class="color-box" style="background-color: white;"></div>
                                            </div>
                                        </li>
                                    </ul>
                                    <!--legend-->


                                </apex:outputPanel>

                                <!--Angular-->

                                <apex:outputPanel layout="block" styleClass="slds-m-top--small"
                                                  html-ng-show="mergeCompList.length > 0 ">
                                    <apex:outputPanel layout="block"
                                                      styleClass="slds-box slds-theme--default slds-container boxPadding">
                                        <div class="slds-section" ng-show="mergeCompList.length > 0">
                                            <div class="slds-section__title">
                                                <h3 class="slds-section__title-action">
                                                    <div class="slds-icon">
                                                        <img style="height:20px" id="changeMe"
                                                             src="/apexpages/slds/latest/assets/icons/utility/switch_60.png"/>
                                                    </div>
                                                    {!$Label.Conflict_Merge_Components_Section_Title}
                                                    <div class="slds-m-left_xx-small mouseOverInfoOuter"
                                                         id="searchInvoiceHelper" onfocus="addMouseOver(this)"
                                                         onmouseover="addMouseOver(this)" tabindex="0">
                                                        <img src="/s.gif" alt="" class="infoIcon" title=""/>
                                                        <div class="mouseOverInfo" id="searchInvoiceHelperText"
                                                             style="display: none; opacity: -0.19999999999999996; left: 16px;">
                                                            <div class="body">This section includes components exist in the deployment and target org, but are different.</div>
                                                        </div>
                                                    </div>
                                                </h3>
                                            </div>
                                            <div class="slds-section__content slds-border_left slds-border_bottom slds-border_top slds-border_right">
                                                <table ng-show="mergeCompList.length > 0 && componentListShow"
                                                       class="slds-table slds-table_cell-buffer list paddingClass">
                                                    <thead>
                                                    <tr class="headerRow">
                                                        <th>No.</th>
                                                        <th>
                                                            <div class=" slds-truncate slds-th__action slds-th__action_form">
                                                                <label class="slds-checkbox">
                                                                    <input type="checkbox"
                                                                           ng-click="checkUncheck(mergeCompList,1);"
                                                                           class="slds-input psli"
                                                                           ng-model="isAllChecked1"/>
                                                                    <span class="slds-checkbox_faux"></span>
                                                                    <span class="slds-assistive-text"></span>
                                                                </label>
                                                            </div>
                                                        </th>
                                                        <th ng-repeat="(key, value) in fieldSet1">
                                                            <a ng-click="safe.refreshOrderBy(key)">{{ safe.orderByColumn == key ?
                                                                safe.isReverse ? value+' ▼' : value+' ▲' : value }}</a>
                                                        </th>
                                                        <th class="Label" style="text-align: center;">
                                                            <a ng-click="safe.refreshOrderBy('compare')">{{safe.orderByColumn ==
                                                                'compare' ? safe.isReverse ? 'Compare ▼' : 'Compare ▲':
                                                                'Compare'}}</a>
                                                        </th>
                                                    </tr>
                                                    </thead>
                                                    <tbody>
                                                    <tr ng-repeat="meta in mergeCompList | orderBy: safe.orderByColumn : safe.isReverse | limitTo: safe.viewLimit"
                                                        ng-if="$index >= safe.metaOffSet"
                                                        class="{{'dataRow ' +meta.styleClassName}}"
                                                        onmouseover="if (window.hiOn){hiOn(this);} "
                                                        onmouseout="if (window.hiOff){hiOff(this);} ">
                                                        <td>{{ $index+1 }}</td>
                                                        <td>
                                                            <div class=" slds-truncate slds-th__action slds-th__action_form">
                                                                <label class="slds-checkbox">
                                                                    <input type="checkbox" name="selectedComps[]"
                                                                           class="slds-input"
                                                                           value="{{ meta['recId'] }}"
                                                                           ng-model="meta['check']"/>
                                                                    <span class="slds-checkbox_faux"></span>
                                                                    <span class="slds-assistive-text"></span>
                                                                </label>
                                                            </div>
                                                        </td>
                                                        <td ng-repeat="(key, value) in fieldSet1Vis">
                                                            {{ meta[key] }}
                                                        </td>
                                                        <td style="text-align: center;">
                                                            <span ng-show="true"
                                                                  ng-style="(meta.isConflict && {'color':  'red'}) || (meta.isAutoResolved && {'color':  'green'})"
                                                                  style="cursor:pointer;"
                                                                  ng-click="getMergeInfo(meta);">{{meta['compare']}}</span>
                                                        </td>
                                                    </tr>
                                                    </tbody>
                                                </table>
                                                <apex:outputPanel html-ng-show="mergeCompList.length > 0 && componentListShow"
                                                        styleClass="slds-m-top--medium slds-grid slds-wrap slds-grid--pull-padded btnPanelMargin pagination"
                                                        layout="block" style="text-align: center;">
                                                    <div class="slds-col--padded slds-size--1-of-1 slds-medium-size--1-of-2 slds-large-size--1-of-3">
                                                        <apex:commandbutton styleClass="btn slds-button slds-button_neutral slds-float_right"
                                                                html-ng-click="safe.listPrevious();" onClick="return false;"
                                                                value="Previous" reRender="none"
                                                                html-ng-disabled="safe.isPrevious() || disableNextPrevious"/>
                                                        <apex:commandbutton styleClass="btn slds-button slds-button_neutral slds-float_right"
                                                                html-ng-click="safe.showFirst();" onClick="return false;"
                                                                value="First" reRender="none"
                                                                html-ng-disabled="safe.isPrevious() || disableNextPrevious"/>
                                                    </div>
                                                    <div class="slds-col--padded slds-size--1-of-1 slds-medium-size--1-of-2 slds-large-size--1-of-3 topMargin">
                                                        Total {{(mergeCompList).length}} component(s), Page
                                                        {{safe.currentPageNo((mergeCompList).length)}} of
                                                        {{safe.totalPageCount((mergeCompList).length)}}
                                                    </div>
                                                    <div class="slds-col--padded slds-size--1-of-1 slds-medium-size--1-of-2 slds-large-size--1-of-3">
                                                        <apex:commandbutton styleClass="btn slds-button slds-button_neutral slds-float_left"
                                                                html-ng-click="safe.listNext((mergeCompList).length);"
                                                                onClick="return false;" value="Next" reRender="none"
                                                                html-ng-disabled="safe.isNext((mergeCompList).length) || disableNextPrevious"/>
                                                        <apex:commandbutton styleClass="btn slds-button slds-button_neutral slds-float_left"
                                                                html-ng-click="safe.showLast((mergeCompList).length);"
                                                                onClick="return false;" value="Last" reRender="none"
                                                                html-ng-disabled="safe.isNext((mergeCompList).length) || disableNextPrevious"/>
                                                    </div>
                                                </apex:outputPanel>
                                                <div style="width: 100%;  padding: 5px;text-align: center;"
                                                     ng-show="mergeCompList.length == 0 && componentListShow">
                                                    <strong>No records to display</strong>
                                                </div>
                                            </div>
                                        </div>
                                    </apex:outputPanel>
                                </apex:outputPanel>
                                    <apex:outputPanel layout="block" styleClass="slds-m-top--small"
                                                      html-ng-show="notMergeCompList.length > 0 ">
                                    <apex:outputPanel layout="block"
                                                      styleClass="slds-box slds-theme--default slds-container paneltopMargin boxPadding">
                                        <div class="slds-section">
                                            <div class="slds-section__title">
                                                <h3 class="slds-section__title-action">
                                                    <div class="slds-icon">
                                                        <img style="height:20px" id="changeMe"
                                                             src="/apexpages/slds/latest/assets/icons/utility/switch_60.png"/>
                                                    </div>
                                                    {!$Label.Not_Merge_Components_Section_Title}
                                                    <div class="slds-m-left_xx-small mouseOverInfoOuter"
                                                         id="searchInvoiceHelper" onfocus="addMouseOver(this)"
                                                         onmouseover="addMouseOver(this)" tabindex="0">
                                                        <img src="/s.gif" alt="" class="infoIcon" title=""/>
                                                        <div class="mouseOverInfo" id="searchInvoiceHelperText"
                                                             style="display: none; opacity: -0.19999999999999996; left: 16px;">
                                                            <div class="body">This section includes components exist in the deployment but don’t exist in the target org or components exist in the deployment and target org, but they are identical.</div>
                                                        </div>
                                                    </div>
                                                </h3>
                                            </div>
                                            <div class="slds-section__content slds-border_left slds-border_bottom slds-border_top slds-border_right">
                                                <table ng-show="notMergeCompList.length > 0 && notMergeCompListShow"
                                                       class="slds-table slds-table_cell-buffer list">
                                                    <thead>
                                                    <tr class="headerRow">
                                                        <th>No.</th>
                                                        <th ng-repeat="(key, value) in fieldSet2">
                                                            <a ng-click="notCommit.refreshOrderBy(key)">{{
                                                                notCommit.orderByColumn == key ? notCommit.isReverse ?
                                                                value+' ▼' : value+' ▲' : value }}</a>
                                                        </th>
                                                    </tr>
                                                    </thead>
                                                    <tbody>
                                                    <tr ng-repeat="meta in notMergeCompList |  orderBy: notCommit.orderByColumn : notCommit.isReverse | limitTo: notCommit.viewLimit"
                                                        ng-if="$index >= notCommit.metaOffSet"
                                                        class="{{'dataRow ' +meta.styleClassName}}"
                                                        onmouseover="if (window.hiOn){hiOn(this);} "
                                                        onmouseout="if (window.hiOff){hiOff(this);} ">
                                                        <td>{{ $index+1 }}</td>
                                                        <td ng-repeat="(key, value) in fieldSet2Vis">
                                                            {{ meta[key] }}
                                                        </td>
                                                    </tr>
                                                    </tbody>
                                                </table>
                                                <apex:outputPanel html-ng-show="notMergeCompList.length > 0 && notMergeCompListShow"
                                                        styleClass="slds-m-top--medium slds-grid slds-wrap slds-grid--pull-padded btnPanelMargin pagination"
                                                        layout="block" style="text-align: center;">
                                                    <div class="slds-col--padded slds-size--1-of-1 slds-medium-size--1-of-2 slds-large-size--1-of-3">
                                                        <apex:commandbutton styleClass="btn slds-button slds-button_neutral slds-float_right"
                                                                html-ng-click="notCommit.listPrevious();"
                                                                onClick="return false;" value="Previous" reRender="none"
                                                                html-ng-disabled="notCommit.isPrevious() || disableNextPrevious"/>
                                                        <apex:commandbutton styleClass="btn slds-button slds-button_neutral slds-float_right"
                                                                html-ng-click="notCommit.showFirst();"
                                                                onClick="return false;" value="First" reRender="none"
                                                                html-ng-disabled="notCommit.isPrevious() || disableNextPrevious"/>
                                                    </div>
                                                    <div class="slds-col--padded slds-size--1-of-1 slds-medium-size--1-of-2 slds-large-size--1-of-3 topMargin">
                                                        Total {{(notMergeCompList).length}} component(s), Page
                                                        {{notCommit.currentPageNo((notMergeCompList).length)}} of
                                                        {{notCommit.totalPageCount((notMergeCompList).length)}}
                                                    </div>
                                                    <div class="slds-col--padded slds-size--1-of-1 slds-medium-size--1-of-2 slds-large-size--1-of-3">
                                                        <apex:commandbutton styleClass="btn slds-button slds-button_neutral slds-float_left"
                                                                html-ng-click="notCommit.listNext((notMergeCompList).length);"
                                                                onClick="return false;" value="Next" reRender="none"
                                                                html-ng-disabled="notCommit.isNext((notMergeCompList).length) || disableNextPrevious"/>
                                                        <apex:commandbutton styleClass="btn slds-button slds-button_neutral slds-float_left"
                                                                html-ng-click="notCommit.showLast((notMergeCompList).length);"
                                                                onClick="return false;" value="Last" reRender="none"
                                                                html-ng-disabled="notCommit.isNext((notMergeCompList).length) || disableNextPrevious"/>
                                                    </div>
                                                </apex:outputPanel>
                                                <div style="width: 100%; padding: 5px;text-align: center;"
                                                     ng-show="notMergeCompList.length == 0 && notMergeCompListShow">
                                                    <strong>No records to display</strong>
                                                </div>
                                            </div>
                                        </div>
                                    </apex:outputPanel>
                                </apex:outputPanel>
                            </apex:outputPanel>

                            <!--            Bundle Comparison panel markup                           -->
                            <apex:outputPanel html-ng-show="CommitStep == 4" layout="block"
                                              styleClass="slds-box slds-theme--default slds-container boxPadding">
                                <div class="bPageTitle" style="padding: 0px 0 0;">
                                    <div class="ptBody">
                                        <div class="content">
                                            <h1 class="slds-text-body_regular slds-truncate slds-align-middle leftMargin"
                                                style="margin-top:0px;">{{PopUpInfo.compType}}</h1>
                                            <h2 class="slds-page-header__title slds-line-height_reset topMargin leftMargin"
                                                style="margin-top:0px;">{{PopUpInfo.compName}}</h2>
                                        </div>
                                    </div>
                                </div>
                                <div class="sf-inner-container"
                                     style="width: 100%; padding-top: 0px; padding-bottom: 20px;">
                                    <div class="bundle_error_msg"> Resolve conflicts for all bundle components first
                                    </div>
                                    <table ng-show="bundleList.length > 0" class="list">
                                        <thead>
                                        <tr class="headerRow">
                                            <th style="text-align: center; width: 10%;">No.</th>
                                            <th class="Label" style="text-align: center; width: 35%;">
                                                {{targetBranchName}}<br/>{{targetDetailsBundle}}&nbsp;
                                            </th>
                                            <th class="Label" style="text-align: center; width: 5%;">&nbsp;Action</th>
                                            <th class="Label" style="text-align: center; width: 35%;">
                                                {{sourceBranchName}}<br/>{{sourceDetailsBundle}}&nbsp;
                                            </th>
                                            <th class="Label" style="text-align: center; width: 15%;">Compare&nbsp;</th>
                                        </tr>
                                        </thead>
                                        <tbody>
                                        <tr ng-repeat="meta in bundleList" class="dataRow">
                                            <td style="text-align: center;">{{ $index+1 }}</td>
                                            <td style="text-align: center;">{{ meta['srcCompName'] }}</td>
                                            <td style="text-align: center;">
                                                <div ng-if="(meta.conflictCode == 4 && meta.moved) || (meta.conflictCode == 3 && meta.moved) || (meta.conflictCode == 5 && meta.moved)">
                                                    <span class="teamSelector" ng-click="updateBundle(meta)">◄</span>
                                                </div>
                                                <div ng-if="(meta.conflictCode == 4 && !meta.moved) || (meta.conflictCode == 3 && !meta.moved) || (meta.conflictCode == 5 && !meta.moved)">
                                                    <span class="teamSelector" ng-click="updateBundle(meta)">►</span>
                                                </div>
                                            </td>
                                            <td style="text-align: left;">
                                                <div ng-if="!((meta.conflictCode == 3 || meta.conflictCode == 5) && meta.moved)">
                                                    {{ meta['tgtCompName'] }}
                                                </div>
                                                <div style="background-color: #ffffb3;"
                                                     ng-if="meta.conflictCode == 3 && meta.moved">Delete {{
                                                    meta['tgtCompName'] }}
                                                </div>
                                                <div style="background-color: #ffffb3;"
                                                     ng-if="meta.conflictCode == 4 && meta.moved">Add {{
                                                    meta['srcCompName']
                                                    }}
                                                </div>
                                                <div style="background-color: #ffffb3;"
                                                     ng-if="meta.conflictCode == 5 && meta.moved">Replaced {{
                                                    meta['srcCompName'] }}
                                                </div>
                                            </td>
                                            <td style="text-align: center;">
                                            <span style="cursor: pointer; color:green" ng-click="getMergeInfo(meta);"
                                                  ng-show="!meta.isConflict && meta.conflictCode == -1">Autoresolved</span>
                                                <span style="cursor: pointer; color:red" ng-click="getMergeInfo(meta);"
                                                      ng-show="meta.isConflict && meta.conflictCode == 1">Conflict</span>
                                                <span style="cursor: pointer; color:green"
                                                      ng-click="getMergeInfo(meta);"
                                                      ng-show="!meta.isConflict && meta.conflictCode == 2">Merged</span>
                                                <span ng-show="meta.conflictCode == 3">New</span>
                                                <span ng-show="meta.conflictCode == 4">Deleted</span>
                                                <span style="color:green" ng-show="meta.conflictCode == 0">Equal</span>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                    <div style="text-align: center; width: 100%; padding-top: 20px;">
                                        <button type="button" class="btn slds-button slds-button_neutral btnBoredrClr"
                                                ng-click="PopUpInfo.closeBundleManualMerge()">Cancel
                                        </button>
                                        <button type="button" class="btn slds-button slds-button_neutral btnBoredrClr"
                                                ng-click="PopUpInfo.bundleManualMerge()">Apply Changes
                                        </button>
                                    </div>
                                </div>
                            </apex:outputPanel>

                            <!--</apex:outputPanel>-->
                        </fieldset>
                    </div>
                </div>
            </div>

        </apex:form>
    </div>

    <!-- Modal -->
    <div aria-hidden="false" role="dialog" class="slds-modal slds-fade-in-close"
         style="opacity:0.9; visibility: visible; display: none;" id="myModal">
        <div class="slds-modal__container" style="width:55%">
            <div class="slds-modal__content">
                <div class="slds-modal__header" style="background-color: #d8dde6;">
                    <button class="slds-button slds-button--icon-inverse slds-modal__close" data-dismiss="modal"
                            aria-hidden="true">&times;
                    </button>
                    <h2 class="slds-text-heading--medium" style="color: red;">Error</h2>
                </div>
                <div class="slds-modal__body"
                     style="padding-left: 20px;padding-right: 20px;padding-top: 20px;padding-bottom: 20px;font-size: 15px;">
                    <p></p>
                </div>
                <div class="modal-footer" style="text-align:center;padding-bottom: 20px;">
                    <button type="button" data-dismiss="modal" class="btn slds-button slds-button_neutral">Ok</button>
                </div>
            </div>
        </div>
    </div>

    <!-- spinner-->
    <div id="loader" class="spinner" style="display: none"></div>

    <script>
        const AUTORESOLVED = 'Autoresolved';
        const CONFLICT = 'Different';
        const NEW = 'New';
        const MERGED = 'Merged';
        const CONSIDER_META = false;
        //----for editor
        var sourceComponentFileMap = {};
        var targetComponentFileMap = {};
        var s1;
        var s2;
        var deploymentName;
        var orgName;

        var selectedFileName = '';
        var selectedFileType = '';


        //var comp;
        var userData;
        var originalModal;
        //---end for editor


        zip.workerScriptsPath = "{!URLFOR($Resource.zipp,'res/js/workers')}/";
        var selectedOrg;
        var patchId;
        Visualforce.remoting.timeout = 120000;
        var targetOrgEntriesMap = {};
        var targetOrgFilesNamesList = [];
        var attList = [];
        var readAttachmentIndex = 0;
        var CTP_commitDataMap = {};
        var messageDots = '.';
        var patchItems = [];

        var normalZip = new JSZip();

        var CTP_bundleTypes = {};
        CTP_bundleTypes['AuraDefinitionBundle'] = 'AuraDefinitionBundle';
        CTP_bundleTypes['LightningComponentBundle'] = 'LightningComponentBundle';

        var CTP_mmap = {};
        CTP_mmap['CustomField'] = true;
        CTP_mmap['CustomLabel'] = true;
        CTP_mmap['CompactLayout'] = true;
        CTP_mmap['WebLink'] = true;
        CTP_mmap['RecordType'] = true;
        CTP_mmap['ListView'] = true;
        CTP_mmap['FieldSet'] = true;
        CTP_mmap['AssignmentRule'] = true;
        CTP_mmap['AutoResponseRule'] = true;
        CTP_mmap['ValidationRule'] = true;
        CTP_mmap['WorkflowTask'] = true;
        CTP_mmap['WorkflowOutboundMessage'] = true;
        CTP_mmap['WorkflowFieldUpdate'] = true;
        CTP_mmap['WorkflowKnowledgePublish'] = true;
        CTP_mmap['WorkflowAlert'] = true;
        CTP_mmap['WorkflowRule'] = true;

        CTP_mmap['SharingOwnerRule'] = true;
        CTP_mmap['SharingCriteriaRule'] = true;
        CTP_mmap['BusinessProcess'] = true;
        CTP_mmap['SharingReason'] = true;
        CTP_mmap['EscalationRule'] = true;
        CTP_mmap['MatchingRule'] = true;
        CTP_mmap['ManagedTopic'] = true;


        var CTP_folderMap = {};
        CTP_folderMap['DocumentFolder'] = 'Document';
        CTP_folderMap['DashboardFolder'] = 'Dashboard';
        CTP_folderMap['ReportFolder'] = 'Report';
        CTP_folderMap['EmailFolder'] = 'EmailTemplate';

        var typesWithMeta = {};
        typesWithMeta['ApexClass'] = true;
        typesWithMeta['ApexTrigger'] = true;
        typesWithMeta['ApexComponent'] = true;
        typesWithMeta['ApexPage'] = true;
        typesWithMeta['EmailTemplate'] = true;
        typesWithMeta['StaticResource'] = true;
        typesWithMeta['Document'] = true;


        var notEditableLi = {};
        notEditableLi['Document'] = true;

        var ValidName = {'ApexClass': [], 
                    'CustomObject': [], 
                    'ApexPage':[], 
                    'CustomTab': [],
                    'Layout': [],
                    'CustomApplication':[],
                    'ExternalDataSource':[],
                    'CustomPermission':[],
                    'CustomField':[],
                    'RecordType':[],
                    'FlexiPage': [],
                    'DataCategoryGroup':[]
                };
        var mainAsyncId;
        var permissionSetEntriesMap = {};

        $(document).ready(function () {
            overridePageMessages();
            $("[id$='dontshowonrender']").css("display", "none");
            $('#spinner').css('display','none');
            getScope().isLoading = false;
            ///console.log(originalModal);
        });


        if (typeof jQuery != 'undefined') {
            $j = jQuery.noConflict();
        }

        function isLightningMode() {
            if (THEME == 'Theme4d') {
                return true;
            }
            return false;
        }


        //****  SLDS  ****//
        $j(document).ready(function () {
            overridePageMessages();
        });


        function getDate(jsonDate) {
            try {
                if (locale && timezone) {
                    return new Date(jsonDate).toLocaleString(locale, {timeZone: timezone})
                }
            } catch (e) {
            }
            return new Date(jsonDate).toUTCString();
        }

        function correctDate(list) {
            for (var i = 0; i < list.length; i++) {
                var jsonDate = list[i].changedOn;
                if (jsonDate != undefined) {
                    list[i].changedOnTxt = getDate(jsonDate);
                }
                jsonDate = list[i].changedOn;
                if (jsonDate != undefined) {
                    list[i].tgtChangedOnTxt = getDate(jsonDate);
                }
            }
        }

        function overridePageMessages() {
            var textureEffect = '';
            textureEffect = 'slds-theme--alert-texture';
            $('.warningM3').addClass('slds-notify slds-notify--toast slds-theme--warning customMessage ' + textureEffect);
            $('.confirmM3').addClass('slds-notify slds-notify--alert slds-theme--success  customMessage ' + textureEffect);
            $('.errorM3').addClass('slds-notify slds-notify--alert slds-theme--error customMessage ' + textureEffect);
            $('.infoM3').addClass('slds-notify slds-notify--toast customMessage ' + textureEffect);

            $('.errorM3').removeClass('errorM3');
            $('.confirmM3').removeClass('confirmM3');
            $('.infoM3').removeClass('infoM3');
            $('.warningM3').removeClass('warningM3');
        }

        $j('.slds-section__title').parent().parent().find('.slds-section').addClass('slds-is-open');
        $j('.slds-section__title').click(function () {
            if ($j(this).parent().parent().hasClass('Minerva18SectionGroupSingle')) {
                if ($j(this).parent().hasClass('slds-is-open')) {
                    $j(this).parent().removeClass('slds-is-open');
                    $j(this).parent().find('.slds-section__content').hide();
                } else {
                    $j(this).parent().parent().find('.slds-section').removeClass('slds-is-open');
                    $j(this).parent().parent().find('.slds-section__content').hide();
                    $j(this).parent().toggleClass('slds-is-open');
                    $j(this).parent().find('.slds-section__content').show();
                }
            } else {
                $j(this).parent().toggleClass('slds-is-open');
                if ($j(this).parent().hasClass('slds-is-open')) {
                    $j(this).parent().find('.slds-icon img').attr('src', "/apexpages/slds/latest/assets/icons/utility/switch_60.png");
                    $j(this).parent().find('.slds-section__content').show();

                } else {
                    $j(this).parent().find('.slds-icon img').attr('src', "/apexpages/slds/latest/assets/icons/utility/chevronright_60.png");
                    $j(this).parent().find('.slds-section__content').hide();
                }
            }
        });
        //****  SLDS  ****//


        var myApp = angular.module("ImpactAnalysisPagination", ['base64', 'ngMessages', 'angularModalService']);



        myApp.$inject = ['$scope', '$filter', '$controller', 'CacheService', 'ModalService', 'ShareService', 'ArchiveService'];


        /******            angularJs modules description                ******/
            //var myApp = angular.module("mergeCommit", ['base64', 'ngMessages', 'angularModalService']);

            // this variable holds the difference object
        var diff3 = {};

        function clearMessage() {
            console.log('clearMessage');
            if ($j('#msg') != undefined) {
                $j('#msg').remove();
            }
        }

        var changedValues = {};
        var uid = 0;
        var directCopy = false;

        function initStack() {
            changedValues = {};
            uid = 0;
        }

        // if bFirst = true, add 2 stack
        // else update
        function add2stack(obj, bFirst) {
            if (bFirst) {
                changedValues[uid] = obj;
                uid++;
                return (uid - 1);
            }
            var id = obj.id;
            if (id != undefined)
                changedValues[id] = obj;
            return id;
        }

        function updateCRC32(Item, newCRC32) {
            if (typesWithMeta[Item.compType]) {// detect which part is edited, and update only this
                if (Item.crc32 != undefined && Item.crc32 != '') {
                    var crc32 = '' + Item.crc32;
                    var crcArray = crc32.split(' ');
                    if (crcArray.length == 2) {
                        if (Item.compType.indexOf('(meta)') > -1) {// update only 2nd part
                            Item.crc32 = crcArray[0] + ' ' + newCRC32;
                        } else {
                            Item.crc32 = newCRC32 + ' ' + crcArray[1];
                        }
                        return;
                    }
                }
                Item.crc32 = newCRC32;
            } else {
                Item.crc32 = newCRC32;
            }
        }


        // analyse and return bundle's crc32 sum (see the specs for detail)
        function composeBundleCrc(mapCrc32) {
            var crcCode = 0;

            // map name => crc32
            var keys = Object.keys(mapCrc32).sort();
            if (keys.length > 0) crcCode = mapCrc32[keys[0]];
            for (var i = 1; i < keys.length; i++) {
                crcCode = Math.round((mapCrc32[keys[i]] + crcCode) / 2);
            }

            return crcCode;
        }


        var Page = function (obj) {
            this.staticLimit = 20;
            this.orderByColumn = 'compName';
            this.isReverse = false;
            this.metaOffSet = 0;
            this.totalRecords = 0;
            this.viewLimit = this.staticLimit;
            if (obj != undefined) {
                if (obj.OrderByColumn != undefined) {
                    this.orderByColumn = obj.OrderByColumn;
                }
                if (obj.isReverse != undefined) {
                    this.isReverse = obj.isReverse;
                }
                if (obj.metaOffSet != undefined) {
                    this.metaOffSet = obj.metaOffSet;
                }
                if (obj.totalRecords != undefined) {
                    this.totalRecords = obj.totalRecords;
                }
                if (obj.viewLimit != undefined) {
                    this.viewLimit = obj.viewLimit;
                }
            }
        };

        Page.prototype.refreshOrderBy = function (orderVal) {
            this.metaOffSet = 0;
            this.viewLimit = this.metaOffSet + this.staticLimit;
            if (orderVal === this.orderByColumn)
                this.isReverse = !this.isReverse;
            else {
                this.isReverse = false;
                this.orderByColumn = orderVal;
            }
        };
        Page.prototype.showFirst = function () {
            this.metaOffSet = 0;
            this.viewLimit = this.staticLimit;
        };
        Page.prototype.listPrevious = function () {
            this.metaOffSet = this.metaOffSet - this.staticLimit;
            if (this.metaOffSet < 0)
                this.metaOffSet = 0;
            this.viewLimit = this.metaOffSet + this.staticLimit;
        };
        Page.prototype.listNext = function (tempTotal) {
            if ((this.metaOffSet + this.staticLimit) < tempTotal) {
                this.metaOffSet = this.metaOffSet + this.staticLimit;
                this.viewLimit = this.metaOffSet + this.staticLimit;
            }
        };
        Page.prototype.showLast = function (tempTotal) {
            this.metaOffSet = tempTotal - (tempTotal % this.staticLimit);
            if (this.metaOffSet == tempTotal && this.metaOffSet != 0) {
                this.metaOffSet = tempTotal - this.staticLimit;
            }
            this.viewLimit = this.metaOffSet + this.staticLimit;
        };
        Page.prototype.isPrevious = function () {
            if (this.metaOffSet < 1)
                return true;
            else {
                return false;
            }
        };
        Page.prototype.isNext = function (tempTotal) {
            if (tempTotal > this.metaOffSet + this.staticLimit) {
                return false;
            } else {
                return true;
            }
        };
        Page.prototype.totalPageCount = function (tempTotal) {
            var totalPage = parseInt(tempTotal % this.staticLimit > 0 ? (tempTotal / this.staticLimit) + 1 : (tempTotal / this.staticLimit));
            return totalPage;

        };
        Page.prototype.currentPageNo = function (tempTotal) {
            var currentPage = 1;
            if (this.metaOffSet < this.staticLimit)
                currentPage = 1;
            else {
                currentPage = Math.ceil(this.metaOffSet / this.staticLimit) + 1;
            }
            return currentPage;
        };


        var isUploadSuccess = true;
        var uploadError;


        myApp.factory('ShareService', function () {
            var _x = {};

            return {
                getX: function () {
                    return _x;
                },
                setX: function (value) {
                    _x = value;
                }
            };
        });


        myApp.controller('CustomController', ['$scope', 'close', 'ShareService', function ($scope, close, ShareService) {
            $scope.question = {
                selected: 1,
                choices: [{
                    id: 1,
                    text: "Replace component in target branch with component from  source branch"
                }, {
                    id: 2,
                    text: "Leave component in target branch untouched"
                }]
            };
            $scope.replace1 = ShareService;
            var params = $scope.replace1.getX();
            if (params != undefined) {
                $scope.question.selected = params.selected == undefined ? 1 : params.selected;
                $scope.alwaysDo = params.alwaysDo;
            } else {
                $scope.question.selected = 1;
                $scope.alwaysDo = false;
            }

            $scope.close = function (result) {
                var choice;
                if (result) {//apply clicked
                    choice = $scope.question.selected;
                } else {// no choice
                    choice = 0;
                }
                $scope.replace1.setX({selected: choice, alwaysDo: $scope.alwaysDo});
                close(choice, 150); // close, but give 500ms for bootstrap to animate
            };

        }]);


        myApp.controller("ImpactAnalysisPaginationController", function ($scope, $base64, $controller, CacheService, ModalService, ShareService, ArchiveService, $filter, $interval, $timeout, filterFilter) {
            //Pagination variables.
            $scope.sourceName = '';
            $scope.targetName = '';
            $scope.paginationList = [];
            $scope.orderByColumn = 'fullName';
            $scope.isReverse = false;
            $scope.metaOffSet = 0;
            $scope.EditBundle = false;
            $scope.staticLimit = 20;
            $scope.viewLimit = $scope.staticLimit;
            var tempObj = {};
            //tempObj['id'] = 'Id';
            tempObj['compType'] = 'Component Type';
            tempObj['fullName'] = 'Component Name';
            //tempObj['changedOn'] = 'Changed On';
            //tempObj['targetChangedOn'] = 'Changed On';
            $scope.fieldSet = tempObj;



            angular.extend(this, $controller('CustomController', {
                $scope: $scope,
                close: close
            }));

            $scope.AlgorithmSet = [{'id': '1', 'name': 'Default'}, {'id': '2', 'name': 'Alternative'}];
            $scope.selectedAlg = '1';
            $scope.branchNewTargetName = '';

            $scope.replace2 = ShareService;
            $scope.isLoading = false;
            $scope.AllowMergeForComponents = true;
            $scope.saveButton = false;

            $scope.componentList = []; // type ConflictWrapper
            $scope.newCompList = []; // type SafeCommitCompWrapper
            $scope.notMergeCompList = []; // type NotCommitCompWrapper
            $scope.mergeCompList = [];
            $scope.bundleList = [];

            // list of pointers to first 2 aforementioned arrays
            $scope.newCompListPtr = [];
            $scope.paginationList = [];

            $scope.componentListShow = true;
            $scope.newCompListShow = true;
            $scope.notMergeCompListShow = true;

            $scope.enableTables = false;
            $scope.CommitStep = 0;
            $scope.EditBundle = false;
            $scope.EditMode = false;
            $scope.disableNextPrevious = false;

            var tempObj1 = {};
            tempObj1['compName'] = 'Component Name';
            tempObj1['compType'] = 'Component Type';
            tempObj1['changedBy'] = 'Changed By';
            tempObj1['changedOn'] = 'Changed On';
            $scope.fieldSet1 = tempObj1;

            var tempObj2 = {};
            tempObj2['compName'] = 'Component Name';
            tempObj2['compType'] = 'Component Type';
            tempObj2['changedBy'] = 'Changed By';
            tempObj2['changedOn'] = 'Changed On';
            $scope.fieldSet2 = tempObj2;

            var tempObj1Vis = {};
            tempObj1Vis['compName'] = 'Component Name';
            tempObj1Vis['compType'] = 'Component Type';
            tempObj1Vis['changedBy'] = 'Changed By';
            tempObj1Vis['changedOnTxt'] = 'Changed On';
            $scope.fieldSet1Vis = tempObj1Vis;

            var tempObj2Vis = {};
            tempObj2Vis['compName'] = 'Component Name';
            tempObj2Vis['compType'] = 'Component Type';
            tempObj2Vis['changedBy'] = 'Changed By';
            tempObj2Vis['changedOnTxt'] = 'Changed On';
            $scope.fieldSet2Vis = tempObj2Vis;

            /*********************************************/

            $scope.IsErrorNotBS = false;
            $scope.groupedItems = [];
            $scope.itemsPerPage = 20;
            $scope.pagedItems = [];
            $scope.currentPage = 0;

            $scope.selectionConflict = [];
            $scope.isAllChecked1 = false;
            $scope.selectionNew = [];
            $scope.isAllChecked2 = false;
            $scope.bIgnoreLocal = false;
            $scope.dataProcessing = false;

            $scope.loading = false;
            $scope.brSelect == '';
            $scope.targetBranchName;
            $scope.sourceBranchName;
            $scope.targetDetails;
            $scope.sourceDetails;
            $scope.targetDetailsBundle;
            $scope.sourceDetailsBundle;
            $scope.alwaysDo = false;

            $scope.bOverwriteAll = false;


            $scope.disableAllUI = false;
            $scope.onlyExistingBranches = false;




            $scope.overallChanges = function () {
                for (var x = 0; x < $scope.paginationList.length; x++) {
                    var rec = $scope.paginationList[x];
                    if ($scope.bOverwriteAll) {
                        if (rec.isConflict) {
                            rec.bkUp4Conflict = rec.isConflict;//save old value
                            rec.isConflict = false;
                            rec.isAutoResolved = true;
                            rec.compare = AUTORESOLVED;
                        }
                    } else {
                        if (rec.bkUp4Conflict != undefined) {
                            rec.isConflict = rec.bkUp4Conflict;
                            rec.isAutoResolved = !rec.isConflict;
                            rec.bkUp4Conflict = undefined;
                            rec.compare = CONFLICT;
                        }
                    }
                }
            };

            $scope.updatePages = function () {
                $scope.safe = new Page({orderByColumn: 'changedOn', isReverse: true});
                $scope.notCommit = new Page({orderByColumn: 'compName', isReverse: true});
            };

            $scope.showHideComponentList = function () {
                $timeout(function () {
                    $scope.componentListShow = ($scope.componentListShow) ? false : true;
                });
            };

            $scope.showHideNewCompList = function () {
                $timeout(function () {
                    $scope.newCompListShow = ($scope.newCompListShow) ? false : true;
                });
            };

            $scope.showHidenotMergeCompList = function () {
                $timeout(function () {
                    $scope.notMergeCompListShow = ($scope.notMergeCompListShow) ? false : true;
                });
            };

            $scope.verify = function (name) {
                //console.log(name +' aganst '+JSON.stringify($scope.allBranches));
                if ($scope.allBranches != undefined && $scope.allBranches.length > 0) {
                    for (var x = 0; x < $scope.allBranches.length; x++) {
                        if ($scope.allBranches[x].branchName === name) {
                            return false;
                        }
                    }
                }
                return true;
            };

            $scope.verify2 = function () {
                //console.log(name +' aganst '+JSON.stringify($scope.allBranches));
                if (targetComponentFileMap != undefined) {
                    return false;
                }
                return true;
            };

            function getMetaCRC(crcA) {
                if (crcA == undefined || crcA == '') return -1;
                var i = crcA.indexOf(' ');
                if (i > -1) {
                    return crcA.substr(i);
                }
                return -1;
            }

            function getMainCRC(crcA) {
                if (crcA == undefined || crcA == '') return -1;
                var i = crcA.indexOf(' ');
                if (i > -1) {
                    return crcA.substr(0, i);
                }
                return -1;
            }

            function splitPairs(componentList) {
                var newList = [];
                if (componentList != undefined && componentList.length > 0) {
                    for (var x = 0; x < componentList.length; x++) {
                        var rec = componentList[x];
                        if (typesWithMeta[rec.compType]) {// verify is meta equals, if true, do NOT add it
                            if (CONSIDER_META) {
                                if (getMetaCRC(rec.patchCRCCode) !== getMetaCRC(rec.targetOrgCRCCode)) {
                                    var newRec = JSON.parse(JSON.stringify(rec));// clone a record
                                    newRec.fileName += '-meta.xml';
                                    newRec.compType += '(meta)';
                                    newRec.isMeta = true;// to detect that is meta - they must not be rendered
                                    newRec.recId += '1'; // add 1 digit to Id, remove it when making operations with SF
                                    rec.meta = newRec;// add pointer to meta extension
                                    newList.push(newRec);
                                }
                                rec.recId += '0';
                                if (getMainCRC(rec.patchCRCCode) !== getMainCRC(rec.targetOrgCRCCode)) {// add main component only if they are different
                                    newList.push(rec);
                                } else {
                                    rec.hidden = true;
                                    newList.push(rec);
                                }
                            } else {
                                rec.recId += '0';
                                if (getMainCRC(rec.patchCRCCode) === getMainCRC(rec.targetOrgCRCCode) && getMetaCRC(rec.patchCRCCode) !== getMetaCRC(rec.targetOrgCRCCode)) {// correct flags only in 1 case
                                    rec.isConflict = false;
                                    rec.isAutoResolved = true;
                                    rec.compare = AUTORESOLVED;
                                }
                                newList.push(rec);
                            }
                        } else {
                            rec.recId += '0';
                            newList.push(rec);
                        }
                    }
                }
                return newList;
            }

            var left_to_resolve = 0;


            $scope.finalLoad = function (mergeCompList, notMergeCompList) {
                console.log('finalLoad');
                $scope.updatePages();
                $scope.paginationList = [];
                $scope.componentList = mergeCompList;
                $scope.notMergeCompList = [];
                $scope.mergeCompList = [];

                // generate the tables of pointers - component from componentList always will be in 1st  table
                for (var x = 0; x < mergeCompList.length; x++) {
                    var comp = mergeCompList[x];
                    if (comp.isAutoResolved) {
                        comp.compare = AUTORESOLVED;
                    } else if (comp.isConflict) {
                        comp.compare = CONFLICT;
                    }
                    $scope.mergeCompList.push(comp);
                }
                // add all new components
                for (var x = 0; x < notMergeCompList.length; x++) {
                    var comp = notMergeCompList[x];

                    comp.compare = NEW;
                    $scope.notMergeCompList.push(comp);
                }
                //debug('retrieve data:'+JSON.stringify($scope.paginationList));
                $scope.enableTables = true;
            };

            // this function load raw data tied with specific component, then add it to  components stack
            $scope.loadComponent = function (meta) {
                if (meta != undefined && meta.attId != undefined) {
                    console.log('load start');

                    var attZip1 = new JSZip();
                    var attZip2 = new JSZip();

                    for (var fileName in targetComponentFileMap) {

                        attZip1.file(fileName, targetComponentFileMap[fileName]);
                    }
                    for (var fileName in sourceComponentFileMap) {
                        attZip2.file(fileName, sourceComponentFileMap[fileName]);
                    }
                    var zip1 = attZip1.generate({type: "base64", compression: "DEFLATE"});
                    var zip2 = attZip2.generate({type: "base64", compression: "DEFLATE"});

                    ArchiveService.addZips(zip1, zip2, meta);

                    /*if (isBundle(meta.compType) == true) {
                        ArchiveService.addZips(zip1, zip2, meta);
                    } else {
                        ArchiveService.addZips(zip1, zip2, meta);
                    }*/
                }
                console.log('load finish');
            };

            $scope.uploadIdSet = function (mList, newBranch) {
                var newList = [];
                if (mList != undefined && mList.length > 0) {// remove last digit from id
                    for (var x = 0; x < mList.length; x++) {
                        newList.push(mList[x].slice(0, 18));
                    }
                }
                $scope.updateMergedData();
            };

            $scope.processUploadResults = function (uploadResult) {
                //console.log('uploadResult='+uploadResult);
                if (uploadResult === 0 || uploadResult === '0') {// extract files from zip
                    isUploadSuccess = true;
                    if ($scope.complete) {
                        $scope.finalize();
                    } else {//continue upload
                        $scope.chainUpload();
                    }
                } else {
                    isUploadSuccess = false;
                    showMessage('update fails');
                }
            };

            $scope.finalize = function () {
                console.log('update was successful');
                $scope.enableTables = false;//set 'need update' flag to false === disable the further edit of components
                $scope.disableSaveButton();
                startRetrieval();
            };

            $scope.chainUpload = function () {
                var attTotalSize = 0;
                var mergeList = [];
                console.log('chainUpload');
                while ($scope.index < $scope.selectionConflict.length) {
                    var conflictComp = $scope.allCompMap[$scope.selectionConflict[$scope.index]];// get info about component
                    //debug(JSON.stringify(conflictComp));
                    if (conflictComp != undefined && isBundle(conflictComp.compType) == false) {
                        if (conflictComp.replace != undefined && conflictComp.replace == 1) {
                            // replace compAttId => repCompAttId
                            // no need in attachment updating
                        } else {
                            var attDescriptor = ArchiveService.getZipDescription($scope.selectionConflict[$scope.index]); // get info about attachment
                            //debug(JSON.stringify(attDescriptor));
                            // form list of MergeWrapper
                            if (attDescriptor != undefined) {
                                var mergeItem = {};
                                if (attTotalSize + attDescriptor.length > 2500000) {
                                    uploadAttachments(JSON.stringify(mergeList));
                                    return;
                                }
                                attTotalSize += attDescriptor.length;
                                mergeItem.recId = conflictComp.recId.slice(0, 18);
                                //mergeItem.lastCompHistoryId = conflictComp.lastCompHistoryId;
                                if (conflictComp.isAutoResolved && attDescriptor.patchCRCCode == undefined) {
                                    mergeItem.patchCRCCode = conflictComp.patchCRCCode;
                                    //debug('null replaced with:'+mergeItem.patchCRCCode);
                                } else {
                                    mergeItem.patchCRCCode = attDescriptor.patchCRCCode;
                                }
                                mergeItem.attId = attDescriptor.attId;
                                mergeItem.base64 = ArchiveService.getZip(attDescriptor.attId);
                                mergeList.push(mergeItem);
                            }
                        }
                    } else if (conflictComp != undefined && ArchiveService.getLength(conflictComp.attId) !== 0) {
                        //debug(JSON.stringify(conflictComp));
                        var mergeItem = {};
                        if (attTotalSize + ArchiveService.getLength(conflictComp.attId) > 2500000) {
                            uploadAttachments(JSON.stringify(mergeList));
                            return;
                        }
                        attTotalSize += ArchiveService.getLength(conflictComp.attId);
                        mergeItem.recId = conflictComp.recId.slice(0, 18);
                        mergeItem.lastCompHistoryId = conflictComp.lastCompHistoryId;
                        mergeItem.patchCRCCode = conflictComp.patchCRCCode;
                        mergeItem.attId = conflictComp.attId;
                        mergeItem.base64 = ArchiveService.getZip(conflictComp.attId);

                        mergeList.push(mergeItem);
                    }
                    $scope.index++;
                }
                $scope.complete = true;
                if (mergeList.length > 0) {
                    uploadAttachments(JSON.stringify(mergeList));
                } else {
                    $scope.finalize();
                }
            };

            $scope.updateMergedData = function () {

                if ($scope.selectionConflict.length > 0) {
                    $scope.index = 0;
                    $scope.complete = false;
                    $scope.chainUpload();
                    return;
                }
                //debug('no selected with conflicts, but may exists a new components');
                $scope.enableTables = false;//set 'need update' flag to false === disable the further edit of components
                $scope.finalize();
                overridePageMessages();
            };

            // commit functionality
            $scope.commit = function () {
                // reset errors flag
                errors = false;
                // clear messages
                overridePageMessages();
                $scope.disableSaveButton();
                $scope.continueCommit();
            };

            // commit functionality
            $scope.continueCommit = function () {

                $scope.allCompMap = {};
                for (var l = 0; l < $scope.componentList.length; l++) {
                    $scope.allCompMap[$scope.componentList[l].recId] = $scope.componentList[l];
                }
                // update attachments and components history
                // choose only components that were changed
                var newConflictList = [];

                for (var x = 0; x < $scope.selectionConflict.length; x++) {
                    var conflictComp = $scope.allCompMap[$scope.selectionConflict[x]];

                    if (conflictComp.compare == MERGED && conflictComp.replace != 2) {// == 1 or undefined
                        newConflictList.push($scope.selectionConflict[x]);

                    }
                }
                $scope.selectionConflict = newConflictList;
                var allSelected = newConflictList.concat($scope.selectionNew);

                //debug('allSelected:'+allSelected.length);
                if (allSelected.length > 0) {
                    isUploadSuccess = false;
                    $scope.uploadIdSet(allSelected);
                } else {
                    $scope.enableTables = false;//set 'need update' flag to false === disable the further edit of components
                    $scope.disableSaveButton();
                    hide();
                    showMessage('No merge components selected');
                    //setMessageOnPage('Complete');
                }

            };

            /******                PopUp methods            ******/
            function isEditable(fileName) {
                if (fileName == undefined) return false;
                var n = fileName.lastIndexOf('.');
                if (n < 0) return false;
                var ext = fileName.substr(n);
                //console.log('check:'+ext);
                return (EDITABLE_EXT[ext] != undefined);
            }

            // edit aura bundle component
            $scope.openPopUpInfo = function (param) {

                if (!ArchiveService.inStack(param.recId)) {
                    $scope.loadComponent(param);
                    $scope.loading = true;
                    //return;
                }

                $scope.PopUpInfo = {};
                $scope.PopUpInfo.bundleTitle = param.fullName;
                $scope.PopUpInfo.compName = param.fullName;
                $scope.PopUpInfo.compType = param.compType;
                $scope.targetDetailsBundle = 'Organization '+ orgName;//+ formatDetail(param.tgtChangedBy) + ' on'+formatDetail(param.tgtChangedOnTxt);
                $scope.sourceDetailsBundle = 'Deployment '+deploymentName + 'changed by'+ formatDetail(param.changedBy) + ' on'+formatDetail(param.changedOnTxt);
                $scope.PopUpInfo.Info = param;

                // create a backup of zip with aura bundle before work - when the cancel btn will be clicked, zip file left untouched
                if (ArchiveService.inStack(param.recId)) {
                    CacheService.push('BACKUP' + param.recId, ArchiveService.getZipDescription(param.recId)[1]);
                }

                if (CacheService.isCached(param.recId)) {
                    CacheService.pop(param.recId, function (data) {
                        $scope.bundleList = data.bundleList;
                        bundleComponentStack = data.bundleComponentStack;
                    });
                } else {//not possible to restore from cache
                    $scope.bundleList = [];
                    var bundles = ArchiveService.getZipDescription(param.recId);
                    var srcMap = bundles[0];
                    var tgtMap = bundles[1];
                    var index = 0; // counter which is = uid in bundleComponentStack
                    // clear bundle stack from previous components
                    bundleComponentStack = [];
                    // form bundleComponentStack from retrieved data with UID = index of bundle elements, use this UID for access a descriptor

                    for (var key in srcMap) {
                        if (srcMap.hasOwnProperty(key)) {
                            var row = {};
                            var srcDescriptor, tgtDescriptor = null, descriptor;
                            //establish the descriptor
                            row.srcCompName = key;
                            srcDescriptor = srcMap[key];
                            descriptor = srcDescriptor;
                            if (tgtMap.hasOwnProperty(key)) {
                                row.tgtCompName = key;
                                tgtDescriptor = tgtMap[key];
                                if (descriptor != undefined) {
                                    descriptor.target = tgtDescriptor.target;//update target file if pair (the only difference)
                                } else {
                                    descriptor = tgtDescriptor;//never executed
                                }
                            }
                            descriptor.isManualMerge = false;
                            //establish the record

                            row.uid = index;
                            row.recId = param.recId;
                            row.attId = param.attId;
                            row.fileName = descriptor.fileName;
                            row.compName = key;
                            row.compType = param.compType;
                            row.isEditable = isEditable(row.fileName);// can be edited, if ext in file allows that
                            row.changedBy = param.changedBy;
                            //row.tgtChangedBy = param.tgtChangedBy;
                            row.changedOnTxt = param.changedOnTxt;
                            row.tgtChangedOnTxt = param.tgtChangedOnTxt;
                            if (param.isAutoResolved == true) {
                                row.conflictCode = -1;// 0 - equals, 1 - conflict, 2 - merged, 3 - new, 4 -deleted, 5 - replaced from target
                                row.isConflict = false;
                            } else {
                                row.conflictCode = 1;// 0 - equals, 1 - conflict, 2 - merged, 3 - new, 4 -deleted, 5 - replaced from target
                                row.isConflict = true;
                            }
                            if (srcDescriptor != undefined && tgtDescriptor != undefined) {// part of Aura with name compName exists in both containers
                                if (srcDescriptor.source === tgtDescriptor.target) {//they are equals
                                    row.conflictCode = 0;
                                    row.isConflict = false;
                                    descriptor.isManualMerge = true;
                                }
                            } else if (srcDescriptor != undefined && tgtDescriptor == undefined) {
                                row.conflictCode = 4;// deleted part of composite component (Aura, Static)
                                row.isConflict = false;
                                row.moved = false;// initial value is always false
                            }// left code = 1, if no block execs
                            // check case conflictCode = 5 :  isConflict && !isEditable
                            if (row.isEditable == false && row.isConflict == true) {// set autoresolved with ability to replace component from the target
                                row.conflictCode = 5;
                                row.isConflict = false;
                            }

                            if (descriptor != undefined) {
                                $scope.bundleList.push(row);
                                bundleComponentStack.push(descriptor);
                                index++;// index plays role of UID
                            }
                        }
                    }


                    for (var key in tgtMap) {// add keys which are not present in srcMap
                        if (tgtMap.hasOwnProperty(key)) {
                            var row = {};
                            var descriptor;
                            if (!srcMap.hasOwnProperty(key)) {
                                descriptor = tgtMap[key];
                                descriptor.isManualMerge = false;
                                descriptor.source = '';

                                row.tgtCompName = key;
                                row.uid = index;
                                row.recId = param.recId;
                                row.attId = param.attId;
                                row.fileName = descriptor.fileName;
                                row.compName = key;
                                row.compType = param.compType;
                                row.conflictCode = 3;// added part of composite component (Aura, Static)
                                row.isEditable = false;// only move/remove possible - always
                                row.isConflict = false;
                                row.moved = false;// initial value is always false
                                row.changedBy = param.changedBy;
                                //row.tgtChangedBy = param.tgtChangedBy;
                                row.changedOnTxt = param.changedOnTxt;
                                row.tgtChangedOnTxt = param.tgtChangedOnTxt;
                                if (descriptor != undefined) {
                                    $scope.bundleList.push(row);
                                    bundleComponentStack.push(descriptor);
                                    index++;// index plays role of UID
                                }
                            }
                        }
                    }
                }
                delete bundles;

                $scope.PopUpInfo.closeBundleManualMerge = function () {
                    var backUpKey = 'BACKUP' + param.recId;
                    if (CacheService.isCached(backUpKey)) {
                        CacheService.pop(backUpKey, function (data) {
                            ArchiveService.updateTargetZip(param.recId, data);
                        });
                    }
                    $scope.EditBundle = false;
                    $scope.CommitStep = 0;
                    delete $scope.PopUpInfo;
                };

                $scope.PopUpInfo.bundleManualMerge = function () {// update original component - ( param)
                    // verify IsManualMerge flags for all  bundle Components
                    if ($scope.bundleList != undefined) {
                        for (var i = 0; i < $scope.bundleList.length; i++) {
                            if ($scope.bundleList[i].isConflict) {
                                //set error message
                                $j('.bundle_error_msg').fadeIn().delay(5000).fadeOut();
                                return;
                            }
                        }
                        //no conflicts, merge passed
                    }

                    var comp = $scope.PopUpInfo.Info;
                    ArchiveService.setMergeFiles(param, $scope.bundleList);

                    param.isConflict = false;
                    param.compare = MERGED;
                    $scope.EditBundle = false;
                    $scope.CommitStep = 0;
                    var archive = {};
                    archive.bundleComponentStack = bundleComponentStack;
                    archive.bundleList = $scope.bundleList;
                    CacheService.push(param.recId, archive);

                };
                clearMessage();
                $scope.CommitStep = 4;
                $scope.EditBundle = true;
                $scope.disableSaveButton();

            };

            function setParameter(list, value) {
                for (var x = 0; x < list.length; x++) {
                    var rec = list[x];
                    if (rec != undefined && notEditableLi[rec.metaType] != undefined && rec.isConflict) {
                        rec.isConflict = false;
                        rec.isManualMerge = true;
                        rec.replace = value;
                        rec.compare = RESOLVED;
                    }
                }
            }


            $scope.getDetail = function (param) {
                var compType = param.compType;
                var fullName = param.fullName;
                var attId = param.attId;
                var fileName = param.fileName;
                var recId = param.recId;
                //console.log('compType--' + compType);
                //console.log('fullName--' + fullName);
                //console.log('attId--' + attId);
                //console.log('fileName--' + fileName);
                //console.log('recId--' + recId);
                selectedFileName = fullName;
                selectedFileType = compType;


                if (compType != undefined && compType != '') {
                    var tempType = folderMap[compType] != undefined ? folderMap[compType] : compType;
                    sourceComponentFileMap = {};
                    targetComponentFileMap = {};
                    //console.log(CTP_commitDataMap);
                    //console.log(attId+'#'+compType+'#'+fileName);
                    var keyfileName = attId + '#' + compType + '#' + fileName;
                    if (CTP_mmap[compType] != undefined) {

                        keyfileName = attId + '#' + compType + '#' + fullName;
                    }
                    if (CTP_commitDataMap[keyfileName] != undefined) {


                        var fullXml = CTP_commitDataMap[keyfileName].data;
                        if (CTP_mmap[compType] != undefined) {

                            var childDataMap = childSplitter(fullXml, compType, fileName);
                            if (childDataMap[compType + '#' + fullName] != undefined) {
                                sourceComponentFileMap[fileName] = childDataMap[compType + '#' + fullName];
                                //sourceComponentFileMap[fullName] = childDataMap[compType + '#' + fullName];
                            }
                        } else {

                            sourceComponentFileMap[fileName] = fullXml;
                            if (CTP_commitDataMap[keyfileName + '-meta.xml'] != undefined) {
                                sourceComponentFileMap[fileName + '-meta.xml'] = CTP_commitDataMap[keyfileName + '-meta.xml'].data;
                            }
                        }
                    } else if (CTP_commitDataMap[attId + '#' + tempType + '#' + fileName] != undefined) {
                        var fullXml = CTP_commitDataMap[attId + '#' + tempType + '#' + fileName].data;
                        sourceComponentFileMap[fileName] = fullXml;
                        //document.getElementById('baseText').value = fullXml;
                    } else if (CTP_bundleTypes[tempType] != undefined) {
                        //console.log('tempType--'+tempType)
                        //console.log('before source');
                        for (var keyName in CTP_commitDataMap) {
                            if (keyName != undefined && keyName.indexOf(attId + '#' + tempType + '#' + fileName + '/') == 0) {
                                var tempFileName = keyName.split(attId + '#' + tempType + '#')[1];
                                sourceComponentFileMap[tempFileName] = CTP_commitDataMap[keyName].data;
                            }
                        }
                        //console.log('after source');
                    }

                    /////
                    if(compType == 'PermissionSet' && permissionSetEntriesMap[fileName] ){

                        targetComponentFileMap[fileName] = permissionSetEntriesMap[fileName].data;
                        $scope.getMergeInfo2(param);
                    }
                    else if (targetOrgEntriesMap[fileName] != undefined) {

                        var singleEntry = targetOrgEntriesMap[fileName];

                        singleEntry.getData(new zip.TextWriter(), function (fullXml) {


                            if (CTP_mmap[compType] != undefined) {

                                var childDataMap = childSplitter(fullXml, compType, fileName);
                                if (childDataMap[compType + '#' + fullName] != undefined) {

                                    //targetComponentFileMap[fullName] = childDataMap[compType + '#' + fullName];
                                    targetComponentFileMap[fileName] = childDataMap[compType + '#' + fullName];
                                }

                                $scope.getMergeInfo2(param);
                            } else {
                                //console.log(fullXml);
                                targetComponentFileMap[fileName] = fullXml;
                                var metXMLFileName = fileName + '-meta.xml';
                                if (targetOrgEntriesMap[metXMLFileName] != undefined) {
                                    var metaXMLEntry = targetOrgEntriesMap[metXMLFileName];
                                    metaXMLEntry.getData(new zip.TextWriter(), function (metaXML) {
                                        targetComponentFileMap[metXMLFileName] = metaXML;
                                        $scope.getMergeInfo2(param);
                                    });
                                } else {
                                    $scope.getMergeInfo2(param);
                                }
                            }
                        });
                    } else if (CTP_bundleTypes[tempType] != undefined) {
                        //console.log('before target');
                        //targetOrgFilesNamesList
                        var fileIndex = 0;

                        function auraFileSearch() {
                            //console.log('fileIndex--'+fileIndex);
                            if (fileIndex < targetOrgFilesNamesList.length) {

                                var auraFileName = targetOrgFilesNamesList[fileIndex];
                                if (auraFileName != undefined && auraFileName.indexOf(fileName + '/') == 0) {

                                    var auraEntry = targetOrgEntriesMap[auraFileName];
                                    //console.log('auraEntry--');
                                    //console.log(auraEntry);
                                    auraEntry.getData(new zip.TextWriter(), function (auraXML) {
                                        targetComponentFileMap[auraFileName] = auraXML;
                                        fileIndex++;
                                        auraFileSearch();
                                    });
                                } else {
                                    fileIndex++;
                                    auraFileSearch();
                                }
                            } else {
                                $scope.openPopUpInfo(param);
                            }
                        }

                        auraFileSearch();
                    } else {
                        $scope.openPopUpInfo(param);
                    }
                }


            };


            function formatDetail(data) {
                if (data == undefined || data == '') {
                    return ' N/A';
                }
                return ' ' + data;
            }

            /**
             *    Define the class to edit a general component of any elemental type
             */

            $scope.getMergeInfo2 = function (param) {

                $scope.targetDetails = 'Organization '+ orgName;// + '###' + 'changed by'+ formatDetail(param.changedBy) + ' on'+formatDetail(param.changedOnTxt);
                $scope.sourceDetails = 'Deployment '+ deploymentName + '###' + 'changed by'+ formatDetail(param.changedBy) + ' on'+formatDetail(param.changedOnTxt); //$scope.targetBranchName + '###' + 'changed by'+ formatDetail(param.tgtChangedBy) + ' on'+formatDetail(param.tgtChangedOnTxt);

                if (isBundle(param.compType) == true && !$scope.EditBundle) {
                    $scope.openPopUpInfo(param);
                    return;
                }

                if (notEditableLi[param.compType]) {
                    if (isModalOpen) return;
                    isModalOpen = true;

                    var template = (isLightningMode() == true) ? 'customL.html' : 'customC.html';
                    $scope.replace2.setX({selected: param.replace, alwaysDo: $scope.alwaysDo});

                    ModalService.showModal({
                        templateUrl: template,
                        controller: 'CustomController',
                        preClose: (modal) => {modal.element.modal('hide'); isModalOpen = false; }
                }).then(function (modal) {
                        modal.element.one('hidden.bs.modal', function () {
                            isModalOpen = false;
                        });
                        modal.element.modal();
                        modal.close.then(function (result) {
                            isModalOpen = false;
                            result = $scope.replace2.getX();
                            ////console.log('choice from service:'+JSON.stringify(result));
                            if (result != undefined) {
                                if (result.selected != 0) {
                                    param.isConflict = false;
                                    param.isManualMerge = true;
                                    param.compare = MERGED;
                                    param.replace = result.selected; // set flag to replace att by scheme: compAttId => repCompAttId
                                    $scope.alwaysDo = result.alwaysDo;
                                    if (result.alwaysDo) {
                                        ////console.log('do for all');
                                        setParameter($scope.paginationList, result.selected);
                                    }
                                }
                            }
                        });
                    });
                    return;
                }

                $scope.loading = false;

                if (!ArchiveService.inStack(param.recId)) {
                    $scope.loadComponent(param);
                    $scope.loading = true;
                    //return;
                }

                if (isBundle(param.compType) == false) {
                    var MergeInfo = ArchiveService.getZipDescription(param.recId);// get descriptor for edited component
                    var recId = param.recId;
                } else {                            //      use alternative stack if aura component
                    var MergeInfo = bundleComponentStack[param.uid];
                    var recId = param.uid;
                }
                var component = param;

                if (MergeInfo != undefined) {
                    itemType = (MergeInfo.IsXML) ? 'XML' : 'TEXT';
                    $scope.PopUp = {}; // its an object to hold info about edited component
                    $scope.PopUp.title = param.compType + ' : ' + param.fullName;
                    $scope.PopUp.compName = param.fullName;
                    $scope.PopUp.compType = param.compType;

                    $scope.PopUp.base = MergeInfo.source;
                    $scope.PopUp.newfile = (MergeInfo.mergeFile) ? MergeInfo.mergeFile : MergeInfo.target;

                    $scope.PopUp.EtalonValue = '';
                    $scope.PopUp.BackUp = MergeInfo.bkUp;
                    $scope.PopUp.ItemId = recId;
                    $scope.PopUp.isXml = MergeInfo.IsXML;
                    //console.log('--$scope.PopUp--');
                    //console.log($scope.PopUp);
                    openMergeEditor($scope.PopUp);

                    $scope.PopUp.ManualMerge = function (txt) {
                        ArchiveService.setMergeFile(recId, txt);
                        $timeout(function () {
                            component.isConflict = false;
                            component.isManualMerge = true;
                            component.compare = MERGED;
                            if ($scope.EditBundle) param.conflictCode = 2;
                            $scope.CommitStep = $scope.EditBundle ? 4 : 0;
                        });
                    };
                    $scope.PopUp.ManualMergeXml = function (xml, xmlBk) {
                        ArchiveService.setMergeFile(recId, xml);
                        ArchiveService.setBkUp(recId, xmlBk);
                        $timeout(function () {
                            component.isConflict = false;
                            component.isManualMerge = true;
                            component.compare = MERGED;
                            if ($scope.EditBundle) param.conflictCode = 2;
                            $scope.CommitStep = $scope.EditBundle ? 4 : 0;
                            $scope.dataProcessing = false;
                            delete param;
                        });
                    };

                    $scope.PopUp.closeManualMerge = function () {
                        $scope.CommitStep = $scope.EditBundle ? 4 : 0;

                        delete param;
                        delete $scope.PopUp;
                    };
                    $scope.PopUp.closeManualMergeXml = function (xmlBk) {
                        $scope.CommitStep = $scope.EditBundle ? 4 : 0;
                        setBkUp(recId, xmlBk);
                        $scope.dataProcessing = false;

                        delete param;
                        delete $scope.PopUp;
                    };

                    if (MergeInfo.IsXML) {
                        $scope.isLoading = true;
                    } else {
                        $scope.isLoading = true;
                    }
                }

                function openMergeEditor(o) {
                    var windowWidth = $(window).width();
                    var windowHeight = $(window).height();
                    var editorPageUrl = '{!editMetaDataPageName}';
                    var link = editorPageUrl;
                    var obj = {};
                    obj.type = o.compType;
                    obj.name = o.compName;
                    obj.mode = o.isXml == true ? 'XML' : 'TXT';
                    obj.tgt = pako.deflate(o.newfile, {to: 'string'});
                    obj.src = pako.deflate(o.base, {to: 'string'});
                    obj.rightTitle = $scope.targetDetails;
                    obj.leftTitle = $scope.sourceDetails;
                    // set dimensions for popup, both inner and outer
                    obj.width = (windowWidth < 600) ? 600 : windowWidth - 150;
                    obj.height = (windowHeight < 500) ? 500 : windowHeight - 270;
                    var popupParams = 'width=' + (obj.width + 50) + ',height=' + (obj.height + 250) + ',resizable=1,scrollbars=1';

                    $j("body").data("userData", obj);

                    var windowTitle = o.compType + ' ' + o.compName;
                    //console.log('link='+link);
                    //console.log('popupParams='+popupParams);
                    var w = window.open(link, 'RW', popupParams);
                    setTitle(w, windowTitle);
                }
                clearMessage();
            };


            $scope.getMergeInfo = function (param) {
                //getDetail(param.compType,param.fullName,param.attId,param.fileName,param.recId);

                $scope.getDetail(param);
                return false;
            };


            // verify are all conflicts for selected components resolved
            $scope.getStatusConflicts = function () {
                for (var x = 0; x < $scope.componentList.length; x++) {
                    if ($scope.componentList[x].check) {// verify only checked
                        if ($scope.componentList[x].isConflict) {
                            return true;
                        } else if (CONSIDER_META && $scope.componentList[x].meta != undefined && $scope.componentList[x].meta.isConflict) {
                            return true;
                        }
                    }
                }
                return false;
            };

            $scope.disableNextPreviousButton = function () {
                $scope.$apply(function () {
                    $scope.disableNextPrevious = true;
                });
            };

            $scope.enableNextPreviousButton = function () {
                $scope.$apply(function () {
                    $scope.disableNextPrevious = false;
                });
            };

            $scope.setDataProcessFlag = function () {
                $timeout(function () {
                    $scope.dataProcessing = true;
                });
            };

            $scope.clearDataProcessFlag = function () {
                $timeout(function () {
                    $scope.dataProcessing = false;
                });
            };

            // Helper method to get selected items
            $scope.selectedComps = function selectedComps() {
                return filterFilter($scope.componentList, {selected: true});
            };

            // Helper method to get selected items
            $scope.selectedComps2 = function selectedComps2() {
                return filterFilter($scope.newCompList, {selected: true});
            };


            // Helper method to get selected items
            $scope.selectedComps3 = function selectedComps3() {
                return filterFilter($scope.mergeCompList, {selected: true});
            };

            $scope.selectRelated = function (meta, list) {
                var i = meta.compType.indexOf('(meta)');
                var filterValue = i == -1 ? (meta.compType + '(meta)') : meta.compType.slice(0, i);
                //////console.log('filterValue:'+filterValue);
                setAll(filterFilter(list, {compType: filterValue, compName: meta.compName}), meta.check);
            };


            // Watch componentList for changes
            $scope.$watch('componentList|filter:{check:true}', function (nv) {
                $scope.selectionConflict = nv.map(function (c) {
                    return c.recId;
                });
            }, true);

            // Watch componentList for changes
            $scope.$watch('newCompList|filter:{check:true}', function (nv) {
                $scope.selectionNew = nv.map(function (c) {
                    return c.recId;
                });
            }, true);

            $scope.checkUncheck = function (compLi, nList) {
                if (nList == 1) {
                    isAllChecked1 = $scope.isAllChecked1;
                    setAll(compLi, isAllChecked1);
                } else if (nList == 2) {
                    isAllChecked2 = $scope.isAllChecked2;
                    setAll(compLi, isAllChecked2);
                } else {
                    isAllChecked1 = false;
                    isAllChecked2 = false;
                    setAll(compLi, false);
                }
            };

            $scope.disableSaveButton = function () {
                $timeout(function () {
                    $scope.saveButton = true;
                });
            };

            $scope.disableUI = function (flag) {
                $timeout(function () {
                    $scope.saveButton = flag;
                    $scope.enableTables = false;
                    $scope.disableAllUI = flag;
                });
            };

            $scope.enableSaveButton = function () {
                $timeout(function () {
                    $scope.mergeButton = false;
                });
            };

            function showMainBlock() {
                getScope().setDataProcessFlag();
            }

            function setAll(array, isAllChecked) {
                for (var index = 0; index < array.length; index++) {
                    if (isAllChecked)
                        array[index].check = true;
                    else
                        array[index].check = false;
                }
            }

            function mergeArray(array, arrayToMerge) {

                if (arrayToMerge.length > 0) {
                    for (var i = 0; i < arrayToMerge.length; i++) {
                        array.push(arrayToMerge[i]);
                    }
                }
            }


            /* code for the new comparison panel */

            var windowSize = getWidth();

            $scope.isLoading = false;
            $scope.STYLE_UPDATED = {"background-color": COLOR_CHANGED};

            $scope.editor = {};
            $scope.editor.viewCollection = []; // pointers to elems of rowCollection
            $scope.editor.counter = 0;
            var counter = 0;
            var guidCounter = 0;

            $scope.editor.copyAllFlag = false;
            $scope.editor.changesOnly = true;
            $scope.editor.ignoreWS = true;
            $scope.editor.isEquivalent = false; // set initial value to true, if obj are different, this value will be reseted
            $scope.isEqual = false;
            $scope.isXmlValid = true;

            $scope.diffXML;
            $scope.file;

            var isEqual;
            var editedInAce = false;
            var editor;


            const DEFAULT_HEIGHT = 592;
            const MIN_HEIGHT = 150;
            const LINE_HEIGHT = 22;
            const FULL_NAME = 'fullName';
            const TAGS_ALWAYS_SHOWN = {};
            TAGS_ALWAYS_SHOWN[FULL_NAME] = true;


            $scope.copyAll = function (directCopy) {
                editor.updateAll(directCopy);
            };


            $scope.updated = function (id) {
                editor.updateRow(id - 1);
            };

            $scope.updateBundle = function (meta) {
                meta.moved = !meta.moved;
            };


            var aceEditor;
            var fileType;

            function setTitle(w, title) {
                if (w) {
                    w.onload = function () {
                        setTimeout(function () {
                            w.document.getElementsByTagName('head')[0].appendChild(document.createElement('title')).appendChild(document.createTextNode(title));
                        }, 5);
                    }
                }
            }


            $scope.cancel = function () {
                // empty all arrays, clear reset vars
                editor.resetVars();
                $scope.PopUp.closeManualMerge();
            };


            var code = '{!errorCode}';

            if (code !== '0') {
                $scope.disableUI(true);
                $j('#spinner').css('display', 'none');
                $scope.loading = false;
                $scope.isLoading = false;
                $scope.enableTables = false;
            }


            //---------------------------------------------------------------
            $scope.clearPagination = function () {
                $scope.$apply(function () {
                    $scope.paginationList = [];
                    $scope.isAllSelected = false;
                    $scope.isAllChecked = false;
                });
            };

            $scope.showPagination = function (tempLi) {
                $scope.$apply(function () {
                    $scope.sourceName = 'sourceName';
                    $scope.targetName = 'targetName';
                    $scope.metaOffSet = 0;
                    $scope.viewLimit = $scope.staticLimit;
                    $scope.orderByColumn = 'componentName';
                    $scope.isReverse = false;
                    var tempObj = {};
                    tempObj['compType'] = 'Component Type';
                    tempObj['fullName'] = 'Component Name';
                    //tempObj['changedOn'] = 'Changed On';
                    //tempObj['targetChangedOn'] = 'Changed On';
                    $scope.fieldSet = tempObj;
                    $scope.paginationList = tempLi;
                });
            };


            $scope.defaultNextPrevious = function () {
                $scope.isAllChecked = false;
            };

            $scope.refreshOrderBy = function (orderVal) {
                $scope.metaOffSet = 0;
                $scope.viewLimit = $scope.metaOffSet + $scope.staticLimit;
                if (orderVal == $scope.orderByColumn)
                    $scope.isReverse = !$scope.isReverse;
                else {
                    $scope.isReverse = false;
                    $scope.orderByColumn = orderVal;
                }
                $scope.defaultNextPrevious();
            };

            $scope.showFirst = function () {
                $scope.metaOffSet = 0;
                $scope.viewLimit = $scope.staticLimit;
                $scope.defaultNextPrevious();
            };

            $scope.listPrevious = function () {
                $scope.metaOffSet = $scope.metaOffSet - $scope.staticLimit;
                if ($scope.metaOffSet < 0)
                    $scope.metaOffSet = 0;
                $scope.viewLimit = $scope.metaOffSet + $scope.staticLimit;
                $scope.defaultNextPrevious();
            };

            $scope.listNext = function (tempTotal) {
                if (($scope.metaOffSet + $scope.staticLimit) < tempTotal) {
                    $scope.metaOffSet = $scope.metaOffSet + $scope.staticLimit;
                    $scope.viewLimit = $scope.metaOffSet + $scope.staticLimit;
                }
                $scope.defaultNextPrevious();
            };

            $scope.showLast = function (tempTotal) {
                $scope.metaOffSet = tempTotal - (tempTotal % $scope.staticLimit);
                if ($scope.metaOffSet == tempTotal && $scope.metaOffSet != 0)
                    $scope.metaOffSet = tempTotal - $scope.staticLimit;
                $scope.viewLimit = $scope.metaOffSet + $scope.staticLimit;
                $scope.defaultNextPrevious();
            };

            $scope.isPrevious = function () {
                if ($scope.metaOffSet < 1)
                    return true;
                else
                    return false;
            };

            $scope.isNext = function (tempTotal) {
                if (tempTotal > $scope.metaOffSet + $scope.staticLimit)
                    return false;
                else
                    return true;
            };

            $scope.totalPageCount = function (tempTotal) {
                var totalPage = parseInt(tempTotal % $scope.staticLimit > 0 ? (tempTotal / $scope.staticLimit) + 1 : (tempTotal / $scope.staticLimit));
                return totalPage;
            };

            $scope.currentPageNo = function (tempTotal) {
                var currentPage = 1;
                if ($scope.metaOffSet < $scope.staticLimit)
                    currentPage = 1;
                else
                    currentPage = Math.ceil($scope.metaOffSet / $scope.staticLimit) + 1;
                return currentPage;
            };
        });


        function saveChanges() {
            show();
            commit();
        }

        function processResults(data) {
            //console.log('uploadResult='+data);
            getScope().processUploadResults(data);
        }

        function commit() {
            getScope().commit();
        }


        function getPatchItemsWithDetailsJS() {
            patchId = '{!patchId}';
            patchItems = [];
            //getPatchItemsWithDetails
            Visualforce.remoting.Manager.invokeAction(
                '{!$RemoteAction.PatchImpactAnalysisController.getPatchItemsWithDetails}',
                patchId,
                handlePatchDetailList
            );
        }

        function handlePatchDetailList(r, e) {
            if (e.status && r) {
                if(r.length > 0){
                    
                    attList = [];
                    CTP_commitDataMap = {};
                    var bodySize = 0;
                    var temp = [];
                    patchItems = r;
                    createValidDATA();
                    for (var index = 0; index < r.length; index++) {
                        var meta = r[index];
                        if (bodySize + meta.attlength > 2000000 && temp.length > 0) {
                            attList.push(temp);
                            bodySize = 0;
                            temp = [];
                        }
                        bodySize = bodySize + meta.attlength;
                        temp.push(meta.attId);
                    }
                    if (temp.length > 0) {
                        attList.push(temp);
                    }
                    if (attList.length > 0) {
                        readAttachmentIndex = 0;
                        getAttachmentsOrgToPatch();
                    } else {
                        hide();
                        showMessage('The definition of some of these components may have been deleted.');
                    }
                }
                else{

                    showMessage('No components found in the deployment or impact analysis functionality is off for existing component types.');
                }
            } else {
                hide();
                showMessage(e.message);
            }
        }

        function getAttachmentsOrgToPatch() {
            if (readAttachmentIndex < attList.length) {
                var attSet = attList[readAttachmentIndex];
                //console.log(attSet);
                console.log('Read Content: ' + (readAttachmentIndex + 1) + '/' + attList.length);
                //CTP_showInfoMessage('Moving components to deployment' + messageDots);
                if (messageDots.length >= 6)
                    messageDots = '.';
                else
                    messageDots += '.';
                Visualforce.remoting.Manager.invokeAction(
                    '{!$RemoteAction.PatchImpactAnalysisController.getAttachments}',
                    JSON.stringify(attSet),
                    handleAttachmentsOrgToPatch
                );
            } else {
                hide();
                //all attachment collected succesfully.
                console.log('All Content Retrieved.');
                //console.log(patchItems);
                calculateCRCCodeOfComponents();
                //CTP_createZipFileOneByOneOrgToPatch();
            }
        }

        function calculateCRCCodeOfComponents() {
            //console.log(CTP_commitDataMap);
            var patchItemIndex = 0;

            function singleItem() {

                if (patchItemIndex < patchItems.length) {

                    var meta = patchItems[patchItemIndex];
                    var API_Name = meta.fullName;
                    var File_Name = meta.fileName;
                    var MetaType = meta.compType;
                    var metId = meta.recId;
                    var attId = meta.attId;

                    meta.patchCRCCode = '';
                    meta.targetOrgCRCCode = '';

                    //Fill CRC code for patch item.
                    var key = '';
                    if (CTP_mmap[MetaType] == undefined) {
                        key = attId + '#' + MetaType + "#" + File_Name;
                    } else {
                        key = attId + '#' + MetaType + "#" + API_Name;
                    }
                    if (CTP_commitDataMap[key] != undefined) {
                        meta.patchCRCCode = CTP_commitDataMap[key].crc32;
                        //console.log('('+CTP_commitDataMap[key].data+')');
                        if (CTP_commitDataMap[key + "-meta.xml"] != undefined) {
                            meta.patchCRCCode = meta.patchCRCCode + ' ' + CTP_commitDataMap[key + "-meta.xml"].crc32;
                        }
                    } else if (CTP_bundleTypes[MetaType] != undefined) {
                        var map32 = {};
                        for (var mapKey in CTP_commitDataMap) {
                            if (mapKey != undefined && mapKey.indexOf(key + '/') == 0) {
                                var fName = mapKey.replace(attId + '#' + MetaType + "#", '');
                                map32[fName] = CTP_commitDataMap[mapKey].crc32;
                            }
                        }
                        meta.patchCRCCode = composeBundleCrc(map32);
                    } else {
                        console.log('Component Not Found In Patch: ' + MetaType + '--' + API_Name);
                    }

                    //Fill CRC code for target org.
                    //console.log(targetOrgEntriesMap);
                    //Fill CRC code for target org.
                if(MetaType == 'PermissionSet' && permissionSetEntriesMap[File_Name] != undefined){

                    meta.targetOrgCRCCode = permissionSetEntriesMap[File_Name].crc32;
                    patchItemIndex++;
                    singleItem();
                }
                else if (targetOrgEntriesMap[File_Name] != undefined) {
                        if (CTP_mmap[MetaType] != undefined) {
                            var parentEntry = targetOrgEntriesMap[File_Name];
                            parentEntry.getData(new zip.TextWriter(), function (text2) {

                                var childDataMap = childSplitter(text2, MetaType, File_Name);
                                if (childDataMap[MetaType + '#' + API_Name] != undefined) {
                                    var tempVar = getCrcWithData(childDataMap[MetaType + '#' + API_Name].trim(), {isInnerType: true});
                                    //console.log('('+tempVar.data+')');
                                    meta.targetOrgCRCCode = tempVar.crc32;
                                }
                                //console.log('Component: '+MetaType+'-'+API_Name+'----'+meta.patchCRCCode+'--vs--'+meta.targetOrgCRCCode);
                                patchItemIndex++;
                                singleItem();
                            });
                        } else {
                            meta.targetOrgCRCCode = targetOrgEntriesMap[File_Name].crc32;
                            if (targetOrgEntriesMap[File_Name + "-meta.xml"] != undefined) {
                                meta.targetOrgCRCCode = meta.targetOrgCRCCode + ' ' + targetOrgEntriesMap[File_Name + "-meta.xml"].crc32;
                            }
                            //console.log('Component: '+MetaType+'-'+API_Name+'----'+meta.patchCRCCode+'--vs--'+meta.targetOrgCRCCode);
                            patchItemIndex++;
                            singleItem();
                        }
                    } else if (CTP_bundleTypes[MetaType] != undefined) {
                        var map32 = {};
                        for (var mapKey in targetOrgEntriesMap) {

                            if (mapKey != undefined && mapKey.indexOf(File_Name + '/') == 0) {
                                var fName = mapKey.replace(attId + '#' + MetaType + "#", '');
                                map32[fName] = targetOrgEntriesMap[mapKey].crc32;
                                /*var fName = mapKey;
                            mapKey[fName] = targetOrgEntriesMap[mapKey].crc32;*/
                            }
                        }
                        meta.targetOrgCRCCode = composeBundleCrc(map32);
                        //console.log('Component: '+MetaType+'-'+API_Name+'----'+meta.patchCRCCode+'--vs--'+meta.targetOrgCRCCode);
                        patchItemIndex++;
                        singleItem();
                    } else {
                        patchItemIndex++;
                        singleItem();
                    }
                } else {
                    filterPatchItemsForPagination();
                }
            }

            singleItem();
        }

        function filterPatchItemsForPagination() {
            //console.log('filterPatchItemsForPagination');
            /*
        Show all components
        Show only those components which exist on the target org
        Show only those components which exist on the target org and are different
        */

            if (patchItems.length > 0) {
                console.log('patchItems.length--' + patchItems.length);
                var viewOption = $("[id$='selectedView']").val();//ShowAll,ExistInTargetOrg,ExistInTargetOrgAndDifferent
                var filteredLi = [];
                var notMergeCompList = [];
                var mergeCompList = [];
                for (var index = 0; index < patchItems.length; index++) {
                    var meta = patchItems[index];
                    meta.styleClassName = '';
                    if (meta.targetOrgCRCCode == undefined || meta.targetOrgCRCCode == '') {
                        meta.styleClassName = 'red';
                        if (viewOption == 'ShowAll') {
                            filteredLi.push(meta);
                            notMergeCompList.push(meta);
                        }
                    } else if (meta.targetOrgCRCCode != meta.patchCRCCode) {
                        meta.styleClassName = 'yellow';
                        //meta.
                        filteredLi.push(meta);
                        mergeCompList.push(meta);
                        //$scope.notMergeCompList = add($scope.notMergeCompList,data.notCommitList);
                    } else {
                        meta.styleClassName = '';
                        if (viewOption != 'ExistInTargetOrgAndDifferent') {
                            filteredLi.push(meta);
                            notMergeCompList.push(meta);
                        }
                    }
                }
                console.log('filteredLi.length--' + filteredLi.length);

                //angular.element(document.getElementById('ImpactAnalysysControllerId')).scope().showPagination(filteredLi);
                correctDate(filteredLi);
                correctDate(mergeCompList);
                correctDate(notMergeCompList);
                getScope().finalLoad(mergeCompList, notMergeCompList);
                getScope().showPagination(filteredLi);
            }
            hide();
        }

        var zipMap = {};

        function handleAttachmentsOrgToPatch(r, e) {
            if (e.status && r) {
                var attReadIndex = 0;
                var readFullAtt = function () {
                    if (attReadIndex < r.length) {
                        var att = r[attReadIndex];
                        var attId = att.attId;
                        var parentId = att.parentId;
                        var metaType = att.compType;
                        var base64str = att.base64;
                        if (zipMap[attId] == undefined) {
                            zipMap[attId] = att.base64;
                        }
                        console.log('Collect Content: ' + (attReadIndex + 1) + '/' + r.length + ' ' + metaType);
                        //CTP_showInfoMessage('Moving components to deployment' +messageDots);
                        if (messageDots.length >= 6)
                            messageDots = '.';
                        else
                            messageDots += '.';
                        // use a Data64URIReader to read the zip from a base64 string
                        zip.createReader(new zip.Data64URIReader(base64str), function (reader) {
                            var EntryIndex = 0;
                            // get all entries from the zip
                            reader.getEntries(function (entries) {
                                if (entries.length) {
                                    var readSingleFile = function () {
                                        if (EntryIndex < entries.length) {
                                            var singleEntry = entries[EntryIndex];
                                            var fileName = singleEntry.filename;
                                            if (CTP_mmap[metaType] == undefined) {
                                                singleEntry.getData(new zip.TextWriter(), function (text2) {
                                                    if(metaType == 'Profile'){

                                                        text2 = validateProfileOnlyforPatchComponents(metaType,text2);
                                                    }
                                                    var result = {};
                                                    result.crc32 = singleEntry.crc32;
                                                    result.data = text2;
                                                    CTP_commitDataMap[attId + '#' + metaType + '#' + fileName] = result;

                                                    EntryIndex++;
                                                    readSingleFile();
                                                });
                                            } else {
                                                entries[EntryIndex].getData(new zip.TextWriter(), function (text) {
                                                    if (fileName != undefined && fileName != 'package.xml') {
                                                        CTP_getChildXml(metaType, text, attId, fileName);
                                                    }
                                                    EntryIndex++;
                                                    readSingleFile();
                                                });
                                            }
                                        } else {
                                            // close the zip reader
                                            reader.close(function () {
                                                // onclose callback
                                                attReadIndex++;
                                                readFullAtt();
                                            });
                                        }
                                    };
                                    readSingleFile();
                                } else {
                                    console.log('!entries.length-' + metaType);
                                    attReadIndex++;
                                    readFullAtt();
                                }
                            });
                        }, function (error) {
                            hide();
                            // onerror callback
                            console.log('Error in reading file from attachments.');
                            console.log(error);
                            console.log(JSON.stringify(error));
                            if (error.message != undefined) {
                                showMessage(error.message);
                            } else {
                                showMessage('Unknown error.');
                            }
                        });
                    } else {
                        //attachment found.
                        readAttachmentIndex++;
                        getAttachmentsOrgToPatch();
                    }
                };
                readFullAtt();
            } else {
                hide();
                showMessage(e.message);
            }
        }

        function startRetrieval() {
            show();
            //setMessageOnPage('Loading Data...');
            deploymentName = '{!JSENCODE(patchName)}';
            orgName = $("[id$='selectedOrg'] option:selected").text();
            console.log('startRetrieval()');
            selectedOrg = $("[id$='selectedOrg']").val();
            patchId = '{!patchId}';
            console.log('selectedOrg--' + selectedOrg);
            console.log('patchId------' + patchId);
            if (selectedOrg != undefined && selectedOrg != '' && patchId != '') {
                Visualforce.remoting.Manager.invokeAction(
                    '{!$RemoteAction.PatchImpactAnalysisController.createRetrievalRequest}',
                    selectedOrg,
                    patchId,
                    handleRetrievalRequest
                );
            } else {

                hide();
            }

            hide();
        }

        function handleRetrievalRequest(r,e)
        {
            mainAsyncId = '';
            if(e.status && r) 
            {
                //
                if(r.isSuccess){

                    console.log('AsyncId--'+r.asyncId);
                    console.log('permissionSetAsyncId--'+r.permissionSetAsyncId);
                    mainAsyncId = r.asyncId;
                    if(r.permissionSetAsyncId != undefined && r.permissionSetAsyncId != ''){
                        getZipData(r.permissionSetAsyncId,selectedOrg,'PermissionSet',handlePermissionSetRetrieval);
                    }
                    else{
                        getZipData(r.asyncId,selectedOrg,'Normal',getPatchItemsWithDetailsJS);
                    }
                }
                else{
                    console.log(r);
                    showMessage('Something went wrong.');
                }
            }
            else
            {
                showMessage(e.message);
            }
        }

        function handlePermissionSetRetrieval(){

            console.log('handlePermissionSetRetrieval');
            getZipData(mainAsyncId,selectedOrg,'Normal',getPatchItemsWithDetailsJS);
        }

        function getZipData(asyncId,recordId,checkType,callback){
            console.log('before etZipStatus(asyncId,recordId).then');
            getZipStatus(asyncId,recordId).then(function(newResult){
                if(newResult.done){
                    if(newResult.errorMessage != null){
                        console.log(newResult);
                        console.log(newResult.errorMessage);
                        showMessage(newResult.errorMessage);
                    }else{
                        if(newResult.status == "Succeeded"){
                            //console.log(newResult);
                            ////////////
                            // use a Data64URIReader to read the zip from a base64 string
                            zip.createReader(new zip.Data64URIReader(newResult.zipFile), function(reader) {

                                if(checkType == 'PermissionSet'){
                                    var EntryIndex = 0;
                                    permissionSetEntriesMap = {};
                                    // get all entries from the zip
                                    reader.getEntries(function(entries) {
                                        if(entries.length)
                                        {
                                            var readSingleFile = function(){
                                                if (EntryIndex < entries.length) 
                                                {
                                                    var singleEntry = entries[EntryIndex];
                                                    var fileName = singleEntry.filename;
                                                    entries[EntryIndex].getData(new zip.TextWriter(), function(fileData) {
                                                        if(fileName != undefined && fileName.indexOf("permissionsets/") == 0) 
                                                        {
                                                            var tempData = {};
                                                            tempData.crc32 = singleEntry.crc32;
                                                            tempData.data = fileData;
                                                            permissionSetEntriesMap[fileName] = tempData
                                                        }
                                                        EntryIndex++;
                                                        readSingleFile();
                                                    });
                                                }
                                                else
                                                {
                                                    // close the zip reader
                                                    reader.close(function() {
                                                      // onclose callback
                                                        callback();
                                                    });
                                                }
                                            }
                                            readSingleFile();
                                        }
                                        else{
                                            callback();
                                        }
                                    });
                                }
                                else{
                                    var EntryIndex = 0;
                                    targetOrgEntriesMap = {};
                                    targetOrgFilesNamesList = [];
                                    // get all entries from the zip
                                    reader.getEntries(function(entries) {
                                        for(index = 0; index < entries.length; index++){
                                            
                                            if(entries[index] != undefined && entries[index].filename != undefined){
                                                targetOrgEntriesMap[entries[index].filename] = entries[index];
                                                targetOrgFilesNamesList.push(entries[index].filename);
                                            }
                                        }
                                        console.log('Done');
                                        callback();
                                    });
                                }
                            }, function(error) {
                                // onerror callback
                                console.log('Error in reading file from attachments.');
                                console.log(error);
                                console.log(JSON.stringify(error));
                                if(error.message != undefined)
                                {
                                    showMessage(error.message);
                                }
                                else
                                {
                                    showMessage('Unknown error.');
                                }
                            });
                            ///////////
                            
                            
                        }else{
                            console.log('Error while receiving zip file. Please check.');
                            console.log(newResult);
                            showMessage('Something went wrong.');
                        }
                    }
                }else{
                    setTimeout(
                        function() {
                            console.log('running again');
                            getZipData(asyncId,recordId,checkType,callback);
                        }, 5000);
                }
            },
            function(err){
                var errSTR = 'Error occured :'+err;
                console.log(errSTR);
                if(errSTR.indexOf('Exceeded max size limit of 6000000') > -1 || errSTR.indexOf('Apex heap size too large') > -1){

                    showMessage('Deployment size is too large for comparison.');
                }
                else
                    showMessage('Error occured :'+err);
            });
        }

        function getZipStatus(asyncId, recordId) {
            return new Promise(function (resolve, reject) {
                Visualforce.remoting.Manager.invokeAction(
                    '{!$RemoteAction.PatchImpactAnalysisController.retrieveZip}',
                    asyncId, recordId,
                    function (result, event) {
                        if (event.status) {
                            resolve(result);
                        } else if (event.type === 'exception') {
                            reject(Error(event.message));
                        } else {
                            reject(Error(event.message));
                        }
                    },
                    {escape: true}
                );
            });
        }

        function CTP_getChildXml(metaType, data, parentId, fileName) {
            var fullName = '';
            if (metaType != 'CustomLabel') {
                fullName = fileName.slice(fileName.indexOf("/") + 1, fileName.lastIndexOf('.')) + ".";
            }

            var typeTagNameMap = {};
            typeTagNameMap['WorkflowAlert'] = 'alerts';
            typeTagNameMap['AssignmentRule'] = 'assignmentRule';
            typeTagNameMap['AutoResponseRule'] = 'autoResponseRule';
            typeTagNameMap['BusinessProcess'] = 'businessProcesses';
            typeTagNameMap['CompactLayout'] = 'compactLayouts';
            typeTagNameMap['EscalationRule'] = 'escalationRule';
            typeTagNameMap['CustomField'] = 'fields';
            typeTagNameMap['FieldSet'] = 'fieldSets';
            typeTagNameMap['WorkflowKnowledgePublish'] = 'knowledgePublishes';
            typeTagNameMap['WorkflowFieldUpdate'] = 'fieldUpdates';
            typeTagNameMap['CustomLabel'] = 'labels';
            typeTagNameMap['ListView'] = 'listViews';
            typeTagNameMap['ManagedTopic'] = 'ManagedTopic';
            typeTagNameMap['MatchingRule'] = 'matchingRules';
            typeTagNameMap['WorkflowOutboundMessage'] = 'outboundMessages';
            typeTagNameMap['WorkflowRule'] = 'rules';
            typeTagNameMap['RecordType'] = 'recordTypes';
            typeTagNameMap['SharingCriteriaRule'] = 'sharingCriteriaRules';
            typeTagNameMap['SharingOwnerRule'] = 'sharingOwnerRules';
            typeTagNameMap['SharingReason'] = 'sharingReasons';
            typeTagNameMap['WorkflowTask'] = 'tasks';
            typeTagNameMap['ValidationRule'] = 'validationRules';
            typeTagNameMap['WebLink'] = 'webLinks';

            var typeParantTagNameMap = {};
            typeParantTagNameMap['AssignmentRule'] = 'AssignmentRules';
            typeParantTagNameMap['AutoResponseRule'] = 'AutoResponseRules';
            typeParantTagNameMap['WebLink'] = 'CustomObject';
            typeParantTagNameMap['FieldSet'] = 'CustomObject';
            typeParantTagNameMap['ListView'] = 'CustomObject';
            typeParantTagNameMap['RecordType'] = 'CustomObject';
            typeParantTagNameMap['CustomField'] = 'CustomObject';
            typeParantTagNameMap['CompactLayout'] = 'CustomObject';
            typeParantTagNameMap['SharingReason'] = 'CustomObject';
            typeParantTagNameMap['ValidationRule'] = 'CustomObject';
            typeParantTagNameMap['BusinessProcess'] = 'CustomObject';
            typeParantTagNameMap['CustomLabel'] = 'CustomLabels';
            typeParantTagNameMap['EscalationRule'] = 'EscalationRules';
            typeParantTagNameMap['ManagedTopic'] = 'ManagedTopics';
            typeParantTagNameMap['MatchingRule'] = 'MatchingRules';
            typeParantTagNameMap['SharingOwnerRule'] = 'SharingRules';
            typeParantTagNameMap['SharingCriteriaRule'] = 'SharingRules';
            typeParantTagNameMap['WorkflowRule'] = 'Workflow';
            typeParantTagNameMap['WorkflowTask'] = 'Workflow';
            typeParantTagNameMap['WorkflowAlert'] = 'Workflow';
            typeParantTagNameMap['WorkflowKnowledgePublish'] = 'Workflow';
            typeParantTagNameMap['WorkflowFieldUpdate'] = 'Workflow';
            typeParantTagNameMap['WorkflowOutboundMessage'] = 'Workflow';


            var x2js = new X2JS({useDoubleQuotes: true, stripWhitespaces: false});
            var childObj = {};
            var parentObj = x2js.xml_str2json(data);
            if (parentObj[typeParantTagNameMap[metaType]] != undefined) {
                var tempObj = parentObj[typeParantTagNameMap[metaType]];
                if (tempObj[typeTagNameMap[metaType]] != undefined) {
                    var childDetails = tempObj[typeTagNameMap[metaType]];
                    if (Array.isArray(childDetails)) {
                        for (var index = 0; index < childDetails.length; index++) {
                            var childVal = childDetails[index];
                            if (childVal != undefined && childVal.fullName != undefined) {
                                var childLiObj = {};
                                childLiObj._xmlns = parentObj[typeParantTagNameMap[metaType]]._xmlns;

                                var childLi = [];
                                childLi.push(childVal);
                                childLiObj[typeTagNameMap[metaType]] = childLi;
                                childObj[typeParantTagNameMap[metaType]] = childLiObj;

                                var childXmlBeforeFormat = x2js.json2xml_str(childObj);
                                if (childXmlBeforeFormat != undefined) {
                                    childXmlBeforeFormat = vkbeautify.xml('<?xml version="1.0" encoding="UTF-8"?>' + childXmlBeforeFormat);
                                    CTP_commitDataMap[parentId + '#' + metaType + '#' + fullName + '' + childVal.fullName] = getCrcWithData(childXmlBeforeFormat, {isInnerType: true});
                                }
                            }
                        }
                    } else {
                        if (childDetails != undefined && childDetails.fullName != undefined) {
                            var childLiObj = {};
                            childLiObj._xmlns = parentObj[typeParantTagNameMap[metaType]]._xmlns;

                            var childLi = [];
                            childLi.push(childDetails);
                            childLiObj[typeTagNameMap[metaType]] = childLi;
                            childObj[typeParantTagNameMap[metaType]] = childLiObj;

                            var childXmlBeforeFormat = x2js.json2xml_str(childObj);
                            if (childXmlBeforeFormat != undefined) {
                                childXmlBeforeFormat = vkbeautify.xml('<?xml version="1.0" encoding="UTF-8"?>' + childXmlBeforeFormat);
                                CTP_commitDataMap[parentId + '#' + metaType + '#' + fullName + '' + childDetails.fullName] = getCrcWithData(childXmlBeforeFormat, {isInnerType: true});
                            }
                        }
                    }
                }
            }
        }

        const XML_HEADER = '<?xml version="1.0" encoding="UTF-8"?>';

        function getCrcWithData(zipData, flags) {
            if (zipData != undefined && flags != undefined && flags.isInnerType == true) {
                zipData = vkbeautify.xml(zipData);
            }
            var result = {};
            result.crc32 = normalZip.crc32(zipData, 32);
            result.data = zipData;
            return result;
        }

        // analyse and return bundle's crc32 sum (see the specs for detail)
        /* function composeBundleCrc(mapCrc32){
        ////console.log('componentStack '+JSON.stringify(mapCrc32));
        var crcCode = 0;

        // map name => crc32
        var keys = Object.keys(mapCrc32).sort();
        if (keys.length > 0 ) crcCode = mapCrc32[keys[0]];
        for (var i = 1; i < keys.length; i++){
            crcCode = Math.round((mapCrc32[keys[i]]+crcCode)/2);
    }

        return crcCode;
    }*/


        function childSplitter(fullXml, metaType, fileName) {
            var childDataMap = {};
            if (fullXml != undefined) {
                var fullName = '';
                if (metaType != 'CustomLabel') {
                    fullName = fileName.slice(fileName.indexOf("/") + 1, fileName.lastIndexOf('.')) + ".";
                }
                var x2js = new X2JS();
                var tgtmap = {};
                var srcjson = x2js.xml_str2json(fullXml);
                if (srcjson != null) {
                    var srcitems;
                    if (metaType == 'CustomLabel') {
                        var srcMetaItem = srcjson.CustomLabels;
                        srcitems = srcMetaItem.labels;
                    } else if (metaType == 'CustomField') {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.fields;
                    } else if (metaType == 'ListView') {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.listViews;
                    } else if (metaType == 'CompactLayout') {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.compactLayouts;
                    } else if (metaType == 'WebLink') {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.webLinks;
                    } else if (metaType == 'RecordType') {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.recordTypes;
                    } else if (metaType == 'FieldSet') {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.fieldSets;
                    } else if (metaType == 'ValidationRule') {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.validationRules;
                    } else if (metaType == 'AssignmentRule') {
                        var srcMetaItem = srcjson.AssignmentRules;
                        srcitems = srcMetaItem.assignmentRule;
                    } else if (metaType == 'AutoResponseRule') {
                        var srcMetaItem = srcjson.AutoResponseRules;
                        srcitems = srcMetaItem.autoResponseRule;
                    } else if (metaType == 'WorkflowTask') {
                        var srcMetaItem = srcjson.Workflow;
                        srcitems = srcMetaItem.tasks;
                    } else if (metaType == 'WorkflowOutboundMessage') {
                        var srcMetaItem = srcjson.Workflow;
                        srcitems = srcMetaItem.outboundMessages;
                    } else if (metaType == 'WorkflowFieldUpdate') {
                        var srcMetaItem = srcjson.Workflow;
                        srcitems = srcMetaItem.fieldUpdates;
                    } else if (metaType == 'WorkflowKnowledgePublish') {
                        var srcMetaItem = srcjson.Workflow;
                        srcitems = srcMetaItem.knowledgePublishes;
                    } else if (metaType == 'WorkflowAlert') {
                        var srcMetaItem = srcjson.Workflow;
                        srcitems = srcMetaItem.alerts;
                    } else if (metaType == 'WorkflowRule') {
                        var srcMetaItem = srcjson.Workflow;
                        srcitems = srcMetaItem.rules;
                    } else if (metaType == 'SharingCriteriaRule') {
                        var srcMetaItem = srcjson.SharingRules;
                        srcitems = srcMetaItem.sharingCriteriaRules;
                    } else if (metaType == 'SharingOwnerRule') {
                        var srcMetaItem = srcjson.SharingRules;
                        srcitems = srcMetaItem.sharingOwnerRules;
                    } else if (metaType == 'BusinessProcess') {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.businessProcesses;
                    } else if (metaType == 'SharingReason') {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.sharingReasons;
                    } else if (metaType == 'EscalationRule') {
                        var srcMetaItem = srcjson.EscalationRules;
                        srcitems = srcMetaItem.escalationRule;
                    } else if (metaType == 'MatchingRule') {
                        var srcMetaItem = srcjson.MatchingRules;
                        srcitems = srcMetaItem.matchingRules;
                    } else if (metaType == 'ManagedTopic') {
                        var srcMetaItem = srcjson.ManagedTopics;
                        srcitems = srcMetaItem.ManagedTopic;
                    }
                    if (srcitems != undefined) {
                        if (srcitems.fullName == undefined) {
                            $.each(srcitems, function (i, v) {
                                tgtmap[fullName + '' + v.fullName] = JSON.stringify(v);
                            });
                        } else {
                            tgtmap[fullName + '' + srcitems.fullName] = JSON.stringify(srcitems);
                        }
                    }
                    if (metadataTypeHeaderMap[metaType] != undefined && metadataTypePreTagMap[metaType] != undefined && metadataTypePostTagMap[metaType] != undefined && metadataTypeFooterMap[metaType] != undefined) {
                        for (var itemName in tgtmap) {
                            tempXml = '';
                            //header
                            tempXml = metadataTypeHeaderMap[metaType];
                            //body
                            tempXml += metadataTypePreTagMap[metaType] + '' + x2js.json2xml_str($.parseJSON(tgtmap[itemName])) + '' + metadataTypePostTagMap[metaType];
                            //footer
                            tempXml += metadataTypeFooterMap[metaType];
                            if (tempXml != '') {
                                childDataMap[metaType + '#' + itemName] = formatXml(tempXml);
                            }
                        }
                    }
                }
            }
            return childDataMap;
        }


        function isEmpty(obj) {
            for (var key in obj) {
                if (obj.hasOwnProperty(key))
                    return false;
            }
            return true;
        }


        const EDITABLE = {
            'application/javascript': true,
            'text/css': true,
            'text/plain': true
        };

        const EDITABLE_EXT = {
            '.js': true,
            '.css': true,
            '.txt': true,
            '.cmp': true,
            '.app': true,
            '.design': true,
            '.evt': true,
            '.intf': true,
            '.auradoc': true,
            '.tokens': true,
            '.xml': true,
            '.cls': true,
            '.trigger': true,
            '.page': true,
            '.object': true,
            '.label': true,
            '.labels': true,
            '.profile': true,
            '.tab': true,
            '.workflow': true,
            '.layout': true,
            '.component': true,
            '.remoteSite': true,
            '.settings': true
        };


        myApp.directive('postrenderAction', postrenderAction);

        /* @ngInject */
        function postrenderAction($timeout) {
            // Directive Interface
            // Defines base properties for the directive.
            var directive = {
                restrict: 'A',
                priority: 101,
                link: link
            };
            return directive;

            // Link Function
            // Provides functionality for the directive during the DOM building/data binding stage.
            function link(scope, element, attrs) {
                $timeout(function () {
                    scope.$evalAsync(attrs.postrenderAction);
                }, 0);
            }
        }

        String.prototype.isXml = function () {
            return this.substr(0, 10).indexOf('<?xml') > -1 ? true : false;
        };

        function getWidth() {
            var width = $j(window).innerWidth() - 100;
            //debug('w='+width);
            return width;
        }

        var maxWidth = getWidth();

        $j(window).on("resize", function () {
            maxWidth = getWidth();

        });

        function isBundle(type) {
            return (type == 'AuraDefinitionBundle' || type == 'StaticResource' || type == 'LightningComponentBundle');
        }

        myApp.factory('ArchiveService', function ($q) {
            var componentStack = {};     // detail info about merged component
            //var zipMap = {};  // map attId=>attachment
            var counter = 0; // number of saved attachments
            var mapCrc32 = {};

            function extractFile(zip1, zip2, comp) {


                var tempSrcZip = new JSZip(zip1, {base64: true});
                var tempTgtZip = new JSZip(zip2, {base64: true});

                if (isBundle(comp.compType) == false) {
                    var descriptor = {};
                    descriptor.attId = comp.attId; // set Attachment's ID which later will be used for update
                    descriptor.compType = comp.compType;
                    descriptor.compName = comp.fullName;
                    descriptor.fileName = comp.fileName;// extract only file specified in fileName field
                    descriptor.length = comp.attlength;
                    descriptor.crc32 = comp.patchCRCCode;
                    descriptor.mime = isEditable(comp.fileName);//detect type of extracted file

                    try {
                        if (descriptor.mime == true) {
                            descriptor.source = tempSrcZip.file(comp.fileName).asText();
                            descriptor.target = tempTgtZip.file(comp.fileName).asText();
                        } else {
                            descriptor.source = tempSrcZip.file(comp.fileName).asBinary();
                            descriptor.target = tempTgtZip.file(comp.fileName).asBinary();
                        }
                    } catch (e) {
                        console.log(e);
                    }
                    descriptor.IsXML = false;
                    if (descriptor.target != undefined && descriptor.target != '') {
                        descriptor.IsXML = descriptor.target.isXml();
                    }
                    return descriptor;// for non-aura return descriptor
                } else {//return array of descriptors for each file in AuraDefinitionBundle (in general: any dir with files)
                    var srcDescrMap;
                    var tgtDescrMap;
                    if (comp.compType == 'AuraDefinitionBundle' || comp.compType == 'LightningComponentBundle') {
                        var srcLst = Object.keys(tempSrcZip.files);
                        srcDescrMap = getDescriptionMap(tempSrcZip, comp, 'source', false);
                        var tgtLst = Object.keys(tempTgtZip.files);
                        tgtDescrMap = getDescriptionMap(tempTgtZip, comp, 'target', false);
                    } else {// Static type
                        srcDescrMap = parseResource(comp, tempSrcZip, 'source');
                        tgtDescrMap = parseResource(comp, tempTgtZip, 'target');
                    }

                    var lst = [];
                    lst.push(srcDescrMap);
                    lst.push(tgtDescrMap);
                    return lst;
                }
            }


            function parseResource(comp, rZip, type) {
                var compName = 'staticresources/' + comp.compName + '.resource';
                var metaName = compName + '-meta.xml';

                var tgtDescrMap = {};
                if (rZip.files[metaName]) {// process content if and only if it contains  meta.xml file
                    var meta = rZip.file(metaName).asBinary();
                    var x2js = new X2JS({useDoubleQuotes: true, stripWhitespaces: false, escapeMode: true});
                    metaObj = x2js.xml_str2json(meta);
                    comp.contentType = metaObj.StaticResource.contentType;
                    var innerZip = metaObj.StaticResource.contentType == 'application/zip';

                    if (innerZip == true) {//unpack inner zip
                        var zip1 = rZip.file(compName).asBinary();
                        var rZip = new JSZip(zip1, {base64: false});
                    }
                    var srcLst = Object.keys(rZip.files);
                    tgtDescrMap = getDescriptionMap(rZip, comp, type, innerZip, metaName);
                }
                return tgtDescrMap;
            }


            function getDescriptionMap(zip, comp, type, displayFullName, excluded) {
                var tgtDescrMap = {};
                var files = Object.keys(zip.files).sort();


                for (var x = 0; x < files.length; x++) {
                    var fileName = files[x];
                    if (fileName == excluded) continue;
                    if (fileName.lastIndexOf('/') == (fileName.length - 1)) continue;// omit paths like css/, etc
                    var descriptor = {};
                    descriptor.attId = comp.attId; // set Attachment's ID which later will be used for update
                    descriptor.compType = comp.compType;
                    descriptor.compName = (displayFullName == true) ? fileName : comp.fullName;
                    descriptor.fileName = fileName;
                    descriptor.length = zipMap[comp.attId].length;
                    descriptor.mime = isEditable(fileName);//detect type of extracted file
                    if (descriptor.mime == true) {
                        descriptor[type] = zip.file(fileName).asText();
                    } else {
                        descriptor[type] = zip.file(fileName).asBinary();
                    }
                    if (descriptor[type] != null && descriptor[type] != '') {
                        descriptor.IsXML = descriptor.compName.indexOf('-meta.xml') == -1 ? false : true;// set xml flag only for meta
                        descriptor.crc32 = zip.crc32(descriptor[type], 32);
                        tgtDescrMap[descriptor.fileName] = descriptor;//return not-null only if target != null
                    }
                }
                return tgtDescrMap;
            }

            function isEditable(fName) {
                var res = false;
                if (fName != undefined && fName != '') {
                    var extPos = fName.lastIndexOf('.');
                    if (extPos > -1) {
                        var ext = fName.substr(extPos);
                        //console.log('check:'+ext);
                        res = EDITABLE_EXT[ext] != undefined;
                    }

                }
                return res;
            }

            function setFile(Item, File) {

                if (File != undefined && File != '' && Item != undefined) {
                    if (Item.IsXML) {
                        var resultXML = File;
                        if (resultXML.isXml()) {
                            Item.mergeFile = resultXML;
                        } else {
                            resultXML = vkbeautify.xmlmin(resultXML, true);
                            Item.mergeFile = '<?xml version="1.0" encoding="UTF-8"?>\n' + vkbeautify.xml(resultXML);
                        }
                    } else {
                        Item.mergeFile = File;
                    }
                    Item.conflictCode = 2;// set flag indicated that new merge File in Bundle has been updated at least once
                } else if (Item != undefined) {
                    Item.mergeFile = File;
                    Item.conflictCode = 2;// set flag indicated that new merge File in Bundle has been updated at least once
                } else {
                    // nothing todo

                }
            }

            function persistFile(Item, tempZip) {
                var isBinary = Item.mime == false;

                if (Item.mergeFile != '' && Item.mergeFile != undefined) {//empty file means delete operation

                    tempZip.file(Item.fileName, Item.mergeFile, {binary: isBinary});// if component with fileName does not exist, create it
                    var crc32 = tempZip.crc32(Item.mergeFile, 32);
                    mapCrc32[Item.fileName] = crc32;
                    updateCRC32(Item, crc32);
                } else {

                    //TODO: verify existence
                    tempZip.remove(Item.fileName);
                    Item.crc32 = '';
                }

            }

            // save 1 merged file back to zip, updates crc32
            function setMergeFile(ItemId, File) {// patch var - depricated
                var len = '' + ItemId;
                if (len < 15) {
                    var bundleItem = bundleComponentStack[ItemId];// pick up component from ephemeral bundle stack
                    setFile(bundleItem, File);
                    return;
                }

                var Item = componentStack[ItemId];// long id - general component, short - bundle; short id always temporal (valid only during edition)
                //set file and  update archive
                var archive = zipMap[Item.attId];// for bundle case - updates contents of bundle zip
                if (archive != undefined) {
                    var tempZip = new JSZip(archive, {base64: true});
                    setFile(Item, File);
                    persistFile(Item, tempZip);
                    zipMap[Item.attId] = tempZip.generate({type: "base64", compression: "DEFLATE"});//repack zip
                }
                //debug('updated,new crc='+Item.crc32);
                Item.isManualMerge = true; // set flag indicated that new merge File has been updated at least once
            }

            function setMergeFiles(masterItem, bundleList) {
                // update archive with data from records with moved = true flag
                var archive = zipMap[masterItem.attId];// for bundle case - updates contents of bundle zip
                if (archive != undefined) {
                    var attZip = new JSZip(archive, {base64: true});

                    var tempZip = null;
                    var isIntermediate = false;
                    // for Aura components and StaticResource with contentType != 'application/zip' add all bundle files directly
                    if (masterItem.compType == 'AuraDefinitionBundle' || masterItem.compType == 'LightningComponentBundle' || (masterItem.compType == 'StaticResource' && masterItem.contentType != 'application/zip')) {
                        tempZip = attZip;
                    } else if (masterItem.compType == 'StaticResource' && masterItem.contentType == 'application/zip') {// use itermediate zip, add it as masterItem.fileName to attZip
                        tempZip = new JSZip();
                        isIntermediate = true;
                    } else {
                        console.log('setMergeFiles: empty zip');
                    }


                    mapCrc32 = {};// empty crc map

                    for (var i = 0; i < bundleList.length; i++) {
                        var bundleComponent = bundleList[i];
                        var bundleItem = bundleComponentStack[i];

                        if (isIntermediate == false) {// update zip with existing components
                            if (bundleComponent.moved == true) {
                                if (bundleComponent.conflictCode == 3) {//remove comp with uid = i, set MergedFile to null in order to trigger deletion
                                    setFile(bundleItem, '');
                                } else if (bundleComponent.conflictCode == 4 || bundleComponent.conflictCode == 5) {//added because they are new or replaced
                                    setFile(bundleItem, bundleItem.source);
                                }
                            } else if (bundleComponent.conflictCode != 4) {// add all from source
                                if (bundleComponent.conflictCode != 2) {
                                    setFile(bundleItem, bundleItem.target);
                                }
                            }
                        } else {// fill zip with all source components, process only those which change the content: with conflictCode  = 0,4,5
                            if (bundleComponent.moved == true) {
                                if (bundleComponent.conflictCode == 3) {
                                    // do nothing with component if code is 3 and moved
                                } else if (bundleComponent.conflictCode == 4 || bundleComponent.conflictCode == 5) {//added because they are new or replaced
                                    setFile(bundleItem, bundleItem.source);
                                }
                            } else if (bundleComponent.conflictCode != 4) {// add all from source
                                if (bundleComponent.conflictCode != 2) {
                                    setFile(bundleItem, bundleItem.target);
                                }
                            }
                        }
                        persistFile(bundleItem, tempZip);

                    }
                    // calc and set the composite crc32 sum
                    // Aura - use polynomial summing
                    // Static - use JSZip method
                    if (isIntermediate == true) {
                        var z = tempZip.generate({base64: false, compression: "DEFLATE"});
                        attZip.file(masterItem.fileName, z, {binary: true});// put zip inside zip
                    }
                    var b64 = attZip.generate({type: "base64", compression: "DEFLATE"});//repack zip
                    zipMap[masterItem.attId] = b64;
                    if (masterItem.compType == 'AuraDefinitionBundle' || masterItem.compType == 'LightningComponentBundle') {
                        masterItem.crc32 = composeBundleCrc(mapCrc32);
                    } else {
                        if (bundleComponentStack != undefined && bundleComponentStack.length > 0) {
                            var crc32_1 = bundleComponentStack[0].crc32;
                            updateCRC32(masterItem, crc32_1);
                        }
                    }
                }
            }


            function setBkUp(Id, xmlBk) {
                if (Id.length > 4) {
                    var descriptor = componentStack[Id];
                } else {
                    var descriptor = bundleComponentStack[Id];
                }
                if (descriptor != undefined) {
                    descriptor.bkUp = xmlBk;
                } else {
                    console.log('error: descriptor is null');
                }
            }


            return {
                addZips: function (zip1, zip2, comp) {// adds the zip; if exists, update with a new data
                    if (componentStack[comp.recId] != undefined) {
                        counter++;
                    }
                    componentStack[comp.recId] = extractFile(zip1, zip2, comp);

                },
                updateTargetZip: function (recId, data) {//  update with a new data
                    if (componentStack[recId] != undefined) {
                        componentStack[recId][1] = data;
                    }
                },
                setMergeFile: function (ItemId, File, patch) {
                    setMergeFile(ItemId, File, patch);
                },
                setMergeFiles: function (meta, bundle) {
                    setMergeFiles(meta, bundle);
                },
                setBkUp: function (Id, xmlBk) {
                    setBkUp(Id, xmlBk);
                },
                getZipDescription: function (recId) {
                    return componentStack[recId];
                },
                getZip: function (attId) {
                    return zipMap[attId];
                },
                setZip: function (attId, data) {
                    zipMap[attId] = data;
                },
                getLength: function (attId) {
                    if (zipMap[attId] != undefined) {
                        return zipMap[attId].length;
                    } else {
                        return 0;
                    }
                },
                initArchiveService: function () {
                    componentStack = {};
                    zipMap = {};
                    counter = 0;
                },
                inStack: function (recId) {
                    return componentStack[recId] != undefined;
                }

            };
        });

        myApp.factory('CacheService', function ($q) {
            var archive = {};// map compId => compressed data
            var counter = 0;
            var callFunct;

            function _getData(recId, callback) {
                callFunct = callback; // set function to return data
                var returnObj = {};
                if (archive[recId] != undefined) {
                    returnObj = JSON.parse(pako.inflate(archive[recId], {to: 'string'}));
                }
                callFunct(returnObj);
            }

            return {
                pop: function (recId, callback) {
                    _getData(recId, function (data) {
                        callback(data);
                    });
                },
                push: function (recId, data) {
                    var compressedData = JSON.stringify(data);
                    if (archive[recId] == undefined) {
                        counter++;
                    }
                    archive[recId] = pako.deflate(compressedData, {to: 'string'});
                },
                initCacheService: function () {
                    archive = {};
                    counter = 0;
                },
                isCached: function (recId) {
                    return archive[recId] != undefined;
                }
            };
        });

        // restore all original view of special symboles in xml file - adopted for SF
        function unescape1XmlChars(str) {
            return str.replace(/&#x27;/g, "'");
        }

        // wrapper for debug, works if flag DEBUG_MODE == true
        function debug(msg) {
            if (DEBUG_MODE) {
                ////console.log(msg);
            }
        }


        function callBackText(updated) {
            var s = getScope();
            var merged = pako.inflate(updated.data, {to: 'string'});
            console.log('merged:');
            if (updated.isXml == true) {
                s.PopUp.ManualMergeXml(merged);
            } else {
                s.PopUp.ManualMerge(merged);
            }
        }

        function isEmpty(val) {
            return val == undefined || val == null || val == '';
        }

        function getScope() {
            return angular.element(document.getElementById('ImpactAnalysysControllerId')).scope();
        }

        //Validation Profile
        function createValidDATA() {
            var Items = patchItems;
            //console.log(Items);
            for(var index in Items)
            {
                if(index < Items.length) {
                    if (ValidName[Items[index].compType] != undefined) {
                        
                        ValidName[Items[index].compType].push(Items[index].fullName);
                        var itemFullName = Items[index].fullName;
                        if(Items[index].compType == 'CustomField' && itemFullName.indexOf('Activity.') == 0 && itemFullName.lastIndexOf('__c') == itemFullName.length - 3) {
                            var tempStr = 'Activity.';
                            var tempItemName = itemFullName.substring(tempStr.length,itemFullName.length);
                            ValidName[Items[index].compType].push('Task.' + tempItemName);
                            ValidName[Items[index].compType].push('Event.' + tempItemName);
                        }
                    }
                }
            }
        }

        function validateProfileOnlyforPatchComponents(metaType,objectForValidation){

            var x2js = new X2JS({useDoubleQuotes : true, stripWhitespaces : false});
            var orignal = x2js.xml_str2json(objectForValidation);
            var ObjectForVal;
            if (orignal.Profile != undefined) {
                ObjectForVal = orignal.Profile;
            }
            else if (orignal.PermissionSet != undefined) {
                ObjectForVal = orignal.PermissionSet;
            }
            if (ObjectForVal != null) {
                //APEX CLASS
                if (ObjectForVal.classAccesses != undefined) {
                    var NewArr =[];
                    var EtallonClasses = ValidName.ApexClass;
                    if(Array.isArray(ObjectForVal.classAccesses))   
                    {
                        for(var index in ObjectForVal.classAccesses) {
                            if (jQuery.inArray(ObjectForVal.classAccesses[index].apexClass, EtallonClasses) !== -1) {
                                NewArr.push(ObjectForVal.classAccesses[index]);
                            }
                        }
                    }
                    else
                    {
                        if (jQuery.inArray(ObjectForVal.classAccesses.apexClass, EtallonClasses) !== -1) {
                            NewArr.push(ObjectForVal.classAccesses);
                        }
                    }
                    if (NewArr.length > 0) {
                        ObjectForVal.classAccesses = NewArr;
                    }
                    else {
                        delete ObjectForVal.classAccesses;
                    }
                }

                //APEX PAGE
                if (ObjectForVal.pageAccesses != undefined) {
                    var NewArr =[];
                    var EtallonPages = ValidName.ApexPage;
                    if(Array.isArray(ObjectForVal.pageAccesses))    
                    {
                        for(var index in ObjectForVal.pageAccesses) {
                            if (jQuery.inArray(ObjectForVal.pageAccesses[index].apexPage, EtallonPages) !== -1) {
                                NewArr.push(ObjectForVal.pageAccesses[index]);
                            }
                        }
                    }
                    else
                    {
                        if (jQuery.inArray(ObjectForVal.pageAccesses.apexPage, EtallonPages) !== -1) {
                            NewArr.push(ObjectForVal.pageAccesses);
                        }
                    }
                    if (NewArr.length > 0) {
                        ObjectForVal.pageAccesses = NewArr;
                    }
                    else {
                        delete ObjectForVal.pageAccesses;
                    }
                }

                //TAB permision
                if (ObjectForVal.tabSettings != undefined && orignal.PermissionSet != undefined) {
                    var NewArr =[];
                    var EtallonTab = ValidName.CustomTab;
                    if(Array.isArray(ObjectForVal.tabSettings)) 
                    {
                        for(var index in ObjectForVal.tabSettings) {
                            if (jQuery.inArray(ObjectForVal.tabSettings[index].tab, EtallonTab) !== -1) {
                                NewArr.push(ObjectForVal.tabSettings[index]);
                            }
                        }
                    }
                    else
                    {
                        if (jQuery.inArray(ObjectForVal.tabSettings.tab, EtallonTab) !== -1) {
                            NewArr.push(ObjectForVal.tabSettings);
                        }
                    }
                    if (NewArr.length > 0) {
                        ObjectForVal.tabSettings = NewArr;
                    }
                    else {
                        delete ObjectForVal.tabSettings;
                    }
                }


                //TAB Profile
                if (ObjectForVal.tabVisibilities != undefined && orignal.Profile != undefined) {
                    var NewArr =[];
                    var EtallonTab = ValidName.CustomTab;
                    if(Array.isArray(ObjectForVal.tabVisibilities)) 
                    {
                        for(var index in ObjectForVal.tabVisibilities) {
                            if (jQuery.inArray(ObjectForVal.tabVisibilities[index].tab, EtallonTab) !== -1) {
                                NewArr.push(ObjectForVal.tabVisibilities[index]);
                            }
                        }
                    }
                    else
                    {
                        if (jQuery.inArray(ObjectForVal.tabVisibilities.tab, EtallonTab) !== -1) {
                            NewArr.push(ObjectForVal.tabVisibilities);
                        }
                    }
                    if (NewArr.length > 0) {
                        ObjectForVal.tabVisibilities = NewArr;
                    }
                    else {
                        delete ObjectForVal.tabVisibilities;
                    }
                }
                
                //profileActionOverrides Profile
                if (ObjectForVal.profileActionOverrides != undefined && orignal.Profile != undefined) {
                    var NewArr =[];
                    var EtallonTab = ValidName.FlexiPage;
                    if(Array.isArray(ObjectForVal.profileActionOverrides))  
                    {
                        for(var index in ObjectForVal.profileActionOverrides) {
                            if (jQuery.inArray(ObjectForVal.profileActionOverrides[index].content, EtallonTab) !== -1) {
                                NewArr.push(ObjectForVal.profileActionOverrides[index]);
                            }
                        }
                    }
                    else
                    {
                        if (jQuery.inArray(ObjectForVal.profileActionOverrides.content, EtallonTab) !== -1) {
                            NewArr.push(ObjectForVal.profileActionOverrides);
                        }
                    }
                    if (NewArr.length > 0) {
                        ObjectForVal.profileActionOverrides = NewArr;
                    }
                    else {
                        delete ObjectForVal.profileActionOverrides;
                    }
                }
                
                //categoryGroupVisibilities Profile
                if (ObjectForVal.categoryGroupVisibilities != undefined && orignal.Profile != undefined) {
                    var NewArr =[];
                    var EtallonTab = ValidName.DataCategoryGroup;
                    if(Array.isArray(ObjectForVal.categoryGroupVisibilities))   
                    {
                        for(var index in ObjectForVal.categoryGroupVisibilities) {
                            if (jQuery.inArray(ObjectForVal.categoryGroupVisibilities[index].dataCategoryGroup, EtallonTab) !== -1) {
                                NewArr.push(ObjectForVal.categoryGroupVisibilities[index]);
                            }
                        }
                    }
                    else
                    {
                        if (jQuery.inArray(ObjectForVal.categoryGroupVisibilities.dataCategoryGroup, EtallonTab) !== -1) {
                            NewArr.push(ObjectForVal.categoryGroupVisibilities);
                        }
                    }
                    if (NewArr.length > 0) {
                        ObjectForVal.categoryGroupVisibilities = NewArr;
                    }
                    else {
                        delete ObjectForVal.categoryGroupVisibilities;
                    }
                }

                //OBJECT
                if (ObjectForVal.objectPermissions != undefined) {
                    var NewArr =[];
                    var EtallonObject = ValidName.CustomObject;
                    if(Array.isArray(ObjectForVal.objectPermissions))   
                    {
                        for(var index in ObjectForVal.objectPermissions) {
                            if (jQuery.inArray(ObjectForVal.objectPermissions[index].object, EtallonObject) !== -1) {
                                NewArr.push(ObjectForVal.objectPermissions[index]);
                            }
                        }
                    }
                    else
                    {
                        if (jQuery.inArray(ObjectForVal.objectPermissions.object, EtallonObject) !== -1) {
                            NewArr.push(ObjectForVal.objectPermissions);
                        }
                    }
                    
                    if (NewArr.length > 0) {
                        ObjectForVal.objectPermissions = NewArr;
                    }
                    else {
                        delete ObjectForVal.objectPermissions;
                    }
                }

                //Layout
                if (ObjectForVal.layoutAssignments != undefined) {
                    var NewArr =[];
                    var EtallonLauout = ValidName.Layout;
                    if(Array.isArray(ObjectForVal.layoutAssignments))   
                    {
                        for(var index in ObjectForVal.layoutAssignments) {
                            if (jQuery.inArray(ObjectForVal.layoutAssignments[index].layout, EtallonLauout) !== -1) {
                                if(ObjectForVal.layoutAssignments[index].recordType != undefined) {
                                    var RecordTypesAvailLi = ValidName.RecordType;
                                    if (jQuery.inArray(ObjectForVal.layoutAssignments[index].recordType, RecordTypesAvailLi) !== -1) {
                                        NewArr.push(ObjectForVal.layoutAssignments[index]);
                                    }
                                }
                                else {
                                    NewArr.push(ObjectForVal.layoutAssignments[index]);
                                }
                            }
                        }
                    }
                    else
                    {
                        if (jQuery.inArray(ObjectForVal.layoutAssignments.layout, EtallonLauout) !== -1) {
                                //NewArr.push(ObjectForVal.layoutAssignments);
                            if(ObjectForVal.layoutAssignments.recordType != undefined) {
                                var RecordTypesAvailLi = ValidName.RecordType;
                                if (jQuery.inArray(ObjectForVal.layoutAssignments.recordType, RecordTypesAvailLi) !== -1) {
                                    NewArr.push(ObjectForVal.layoutAssignments);
                                }
                            }
                            else {
                                NewArr.push(ObjectForVal.layoutAssignments);
                            }
                        }
                    }
                    
                    if (NewArr.length > 0) {
                        ObjectForVal.layoutAssignments = NewArr;
                    }
                    else {
                        delete ObjectForVal.layoutAssignments;
                    }
                }

                //recordType
                if (ObjectForVal.recordTypeVisibilities != undefined) {
                    var NewArr =[];
                    var EtallonObject = ValidName.RecordType;
                    if (EtallonObject.length > 0) {
                        if(Array.isArray(ObjectForVal.recordTypeVisibilities))  
                        {
                            for(var index =0; index < ObjectForVal.recordTypeVisibilities.length; index++) {
                                var RecordTypeName = ObjectForVal.recordTypeVisibilities[index].recordType; 
                                if (jQuery.inArray(RecordTypeName, EtallonObject) !== -1) {
                                    NewArr.push(ObjectForVal.recordTypeVisibilities[index]);
                                }
                            }
                        }
                        else
                        {
                            var RecordTypeName = ObjectForVal.recordTypeVisibilities.recordType;
                            if (jQuery.inArray(RecordTypeName, EtallonObject) !== -1) {
                                NewArr.push(ObjectForVal.recordTypeVisibilities);
                            }
                        }
                    }
                    if (NewArr.length > 0) {
                        ObjectForVal.recordTypeVisibilities = NewArr;
                    }
                    else {
                        delete ObjectForVal.recordTypeVisibilities;
                    }
                }

                //fieldPermissions
                if (ObjectForVal.fieldPermissions != undefined) {
                    var NewArr =[];
                    var EtallonObject = ValidName.CustomField;
                    var objectNames = {};
                    for(var index =0; index < ValidName.CustomObject.length; index++) {

                        objectNames[ValidName.CustomObject[index]] = ValidName.CustomObject[index];
                    }
                    //console.log('objectNames');
                    //console.log(objectNames);
                    if (EtallonObject.length > 0 || ValidName.CustomObject.length > 0) {
                        if(Array.isArray(ObjectForVal.fieldPermissions))    
                        {
                            for(var index =0; index < ObjectForVal.fieldPermissions.length; index++) {
                                var fieldName = ObjectForVal.fieldPermissions[index].field;
                                var objectNameForPermission = fieldName.split('.')[0];
                                //console.log('objectNameForPermission--'+objectNameForPermission)
                                if (jQuery.inArray(fieldName, EtallonObject) !== -1 || objectNames[objectNameForPermission] != undefined) {
                                    NewArr.push(ObjectForVal.fieldPermissions[index]);
                                }
                            }
                        }
                        else
                        {
                            var fieldName = ObjectForVal.fieldPermissions.field;
                            var objectNameForPermission = fieldName.split('.')[0];
                            if (jQuery.inArray(fieldName, EtallonObject) !== -1 || objectNames[objectNameForPermission] != undefined) {
                                NewArr.push(ObjectForVal.fieldPermissions);
                            }
                        }
                    }
                    if (NewArr.length > 0) {
                        ObjectForVal.fieldPermissions = NewArr;
                    }
                    else {
                        delete ObjectForVal.fieldPermissions;
                    }
                }
                
                //applicationVisibilities
                if (ObjectForVal.applicationVisibilities != undefined) {
                    var NewArr =[];
                    var EtallonPages = ValidName.CustomApplication;
                    if(Array.isArray(ObjectForVal.applicationVisibilities)) 
                    {
                        for(var index in ObjectForVal.applicationVisibilities) {
                            if (jQuery.inArray(ObjectForVal.applicationVisibilities[index].application, EtallonPages) !== -1) {
                                NewArr.push(ObjectForVal.applicationVisibilities[index]);
                            }
                        }
                    }
                    else
                    {
                        if (jQuery.inArray(ObjectForVal.applicationVisibilities.application, EtallonPages) !== -1) {
                            NewArr.push(ObjectForVal.applicationVisibilities);
                        }
                    }
                    
                    if (NewArr.length > 0) {
                        ObjectForVal.applicationVisibilities = NewArr;
                    }
                    else {
                        delete ObjectForVal.applicationVisibilities;
                    }
                }
                
                //externalDataSourceAccesses
                if (ObjectForVal.externalDataSourceAccesses != undefined) {
                    var NewArr =[];
                    var EtallonPages = ValidName.ExternalDataSource;
                    if(Array.isArray(ObjectForVal.externalDataSourceAccesses))  {
                        for(var index in ObjectForVal.externalDataSourceAccesses) {
                            if (jQuery.inArray(ObjectForVal.externalDataSourceAccesses[index].externalDataSource, EtallonPages) !== -1) {
                                NewArr.push(ObjectForVal.externalDataSourceAccesses[index]);
                            }
                        }
                    }
                    else {
                        if (jQuery.inArray(ObjectForVal.externalDataSourceAccesses.externalDataSource, EtallonPages) !== -1) {
                            NewArr.push(ObjectForVal.externalDataSourceAccesses);
                        }
                    }
                    if (NewArr.length > 0) {
                        ObjectForVal.externalDataSourceAccesses = NewArr;
                    }
                    else {
                        delete ObjectForVal.externalDataSourceAccesses;
                    }
                }
                
                //customPermissions
                if (ObjectForVal.customPermissions != undefined) {
                    var NewArr =[];
                    var EtallonPages = ValidName.CustomPermission;
                    if(Array.isArray(ObjectForVal.customPermissions))   
                    {
                        for(var index in ObjectForVal.customPermissions) {
                            if (jQuery.inArray(ObjectForVal.customPermissions[index].name, EtallonPages) !== -1) {
                                NewArr.push(ObjectForVal.customPermissions[index]);
                            }
                        }
                    }
                    else
                    {
                        if (jQuery.inArray(ObjectForVal.customPermissions.name, EtallonPages) !== -1) {
                            NewArr.push(ObjectForVal.customPermissions);
                        }
                    }
                    if (NewArr.length > 0) {
                        ObjectForVal.customPermissions = NewArr;
                    }
                    else {
                        delete ObjectForVal.customPermissions;
                    }
                }
            }
            /*if(ObjectForVal != null && ObjectForVal.userPermissions != undefined)
                delete ObjectForVal.userPermissions;
            if(ObjectForVal != null && ObjectForVal.loginIpRanges != undefined)
                delete ObjectForVal.loginIpRanges;
            */
            if (orignal.Profile != undefined && ObjectForVal != null) {
                 orignal.Profile = ObjectForVal;
            }
            
            var returnXML = x2js.json2xml_str(orignal);
            returnXML = vkbeautify.xml(returnXML);
            returnXML = '<?xml version="1.0" encoding="UTF-8"?>\n'+returnXML+'\n';
            return returnXML;
        }

    </script>

</apex:page>