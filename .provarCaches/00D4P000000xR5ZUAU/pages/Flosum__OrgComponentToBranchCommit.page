<apex:page standardController="Flosum__Org_Component__c" recordSetVar="orgComp" extensions="Flosum.OrgComponentToBranchCommitController" sidebar="false"  doctype="html-5.0" cache="false" id="pg">
    <c:TrackPanel />
    <apex:slds />
    <apex:includeScript value="{!URLFOR($Resource.Flosum__jszipmaster,'jszip-master/flosumsf/flosumsf1.6.0.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__jszipmaster, 'jszip-master/dist/jszip.js')}"/>
    <script type="text/javascript" async="" src="{!URLFOR($Resource.zipp,'res/ga.js')}"></script>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__zipp,'res/js/zip.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__zipp,'res/js/workers/deflate.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__zipp,'res/js/workers/inflate.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__zipp,'res/js/workers/z-worker.js')}"/>

    <c:DynamicLookupScript />
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/diffxmllib.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__ContentEditor, 'beauty/forMatXML.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/pako.min.js')}"/>
    <!--        added resources      -->
    <apex:stylesheet value="{!URLFOR($Resource.Flosum__Merge, 'Merge/css/bootstrapSF.min.css')}" />
    
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/jquery-2.1.4.min.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/angular.min.js')}"/> 
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/difflib.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/angular-base64.min.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/deep-diff-0.3.3.min.js')}"/>

    <apex:includeScript value="{!$Resource.Flosum__xmltojson}"/>
    <apex:includeScript value="{!$Resource.Flosum__X2JS}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/bkup.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/fullbkup.js')}"/>
    
    <c:Wait />
 
    

    <style>
        div#searchInvoiceHelperText {
            left: 50px !important;
        }
        .message {
            list-style-type: none;
        }
        
        .message .messageText {
            color: white !important;
        }
        .message .messageTextBlack {
            color: black !important;
        }

        .message .messageText h4{
            color: white !important;
        }
        .customMessage * {
            color: #fff!important
        }
        .boxPadding {
            padding: .5rem !important;
        }
        .customMessage {
            margin: 0px !important;
            opacity: 1!important;
            width: 100%;
            font-size: 13px;
            border: 0px;
            padding-left: 10px;
        }
        .pagination { 
            padding: 1%; 
        } 
        div .pagination { 
            text-align: center; 
        } 
        td .dataCell label { 
            font-weight: normal; 
        } 
        span.paginationEle { 
            margin-left: 4px; 
        } 
        .pagination input { 
            margin-left: 4px; 
        } 
        hr.pBlockDescription {
            margin-top: 0%;
            border-bottom: 1px solid #DBDBDB;
        }
        .disablePageLink{
            pointer-events : none;
        }
        .overrideCommitAlign{
            text-align: center;
        }
        .lbcls {
            font-weight: 700 !important;
        }
        .slds-table th {
            font-weight: 700 !important;
        }
    </style>
    <apex:outputPanel layout="block" styleClass="slds-scope">
        <apex:pagemessages id="msg"/>
        <apex:form rendered="{!if(orgName != null,true,false)}" id="fullform" styleClass="slds-form--stacked">
            <apex:actionfunction action="{!showMessage}" reRender="msg" name="showMessage" onComplete="hide();overridePageMessages();">
                <apex:param assignTo="{!message}" value="" name="newstr"/>
            </apex:actionfunction>
            <apex:actionfunction name="commitByApex" action="{!commitInChunk}" onComplete="populatePatch('{!patchListJSON}','{!logsListJSON}','{!logId}', '{!validateOnly}');overridePageMessages();">
                <apex:param assignTo="{!commitChunkJSON}" value="" name="chunkJSON"/>
            </apex:actionfunction>
            <apex:actionfunction name="insertPatchManifest" action="{!populatePatch}"  onComplete="insertPatchBkup('{!validateOnly}');overridePageMessages();">
                <apex:param assignTo="{!patchId}" value="" name="patchId"/>
            </apex:actionfunction>
            <apex:actionfunction name="insertAtt" action="{!insertMergeAttachment}"  onComplete="buildBlocks();overridePageMessages();">
                <apex:param assignTo="{!attStr}" value="" name="attStr"/>
                <apex:param assignTo="{!patchId}" value="" name="patchId"/>
            </apex:actionfunction>
            <apex:actionFunction name="refreshOnBranchSelect" reRender="tb,brOption,msg" oncomplete="hide();overridePageMessages();" />
            <apex:actionfunction name="synchronize" action="{!synchronize}" reRender="none">
                <apex:param assignTo="{!comment}" value="" name="comment"/>
            </apex:actionfunction>
            <div ng-app="snapCommit">               
                <div ng-controller ="Snap2BranchCommitControllerAJS"  id="angularControllerId">
                    <div class="ng-cloak">
                    <!-- choose the branch to commit to -->                 
                        <apex:outputPanel layout="block" styleClass="slds-page-header" html-ng-show="CommitStep == 0">
                            <div class="slds-media__body">
                                <h1 class="slds-page-header__title slds-truncate slds-align-middle" >{!$Label.Commit_To_Branch_Title}</h1>
                                <p>
                                    {!$Label.Commit_To_Branch_Description_1}
                                </p>
                                <p>
                                    {!$Label.Commit_To_Branch_Description_4}
                                </p>
                            </div>
                        </apex:outputPanel>
                        <apex:outputPanel layout="block" styleClass="slds-page-header" html-ng-show="CommitStep == 1">
                            <div class="slds-media__body">
                                <h1 class="slds-page-header__title slds-truncate slds-align-middle" >{!$Label.Commit_To_Branch_Title_2}</h1>
                                <p>{!$Label.Commit_To_Branch_Description_5}</p>
                            </div>
                        </apex:outputPanel>

                        <apex:outputPanel layout="block" html-ng-show="CommitStep == 0" id="tbl" styleClass="slds-box slds-theme--default slds-container">
                            <apex:outputPanel id="brOption">
                                    <apex:outputPanel styleClass="slds-form-element slds-size--4-of-12 slds-m-bottom_small slds-m-top_small" layout="block">
                                        <apex:outputLabel styleClass="slds-form-element__label slds-text-heading_regular lbcls" value="Org" />
                                        <div class="slds-form-element__control">
                                            <apex:outputText style="background: #eef1f6;" styleClass="slds-input slds-text-heading_regular" value="{!orgName}"/>
                                        </div>
                                    </apex:outputPanel>
                        
                                    <apex:outputPanel styleClass="slds-form-element slds-size--4-of-12 slds-m-bottom_small slds-m-top_small" layout="block">
                                        <apex:outputLabel styleClass="lbcls slds-form-element__label slds-text-heading_regular" value="{!$ObjectType.Flosum__Repository__c.Label}" />
                                        <div class="slds-form-element__control">
                                            <div class="slds-select_container">
                                                <apex:selectList value="{!selectedRepository}" multiselect="false" size="1" styleClass="slds-select slds-text-heading_regular" disabled="{!if(GoToCommitType == 'oncommit',true,false)}">
                                                    <apex:selectOptions value="{!repositoryOptions}"/>
                                                    <apex:actionSupport event="onchange" action="{!listBranches}"  reRender="brOption,msg" oncomplete="hide();" onsubmit="show();"/>
                                                </apex:selectList>
                                            </div>
                                        </div>
                                    </apex:outputpanel>
                                    
                                    <apex:outputPanel styleClass="slds-form-element slds-size--4-of-12 slds-m-bottom_small slds-m-top_small"  rendered="{!commitList.size > 0}">
                                        <apex:outputLabel styleClass="lbcls slds-form-element__label slds-text-heading_regular" value="{!$Label.flosum__commit_to_branch_label}" />
                                            <div class="slds-form-element__control slds-grid">
                                                <apex:inputHidden id="branchTargetId" value="{!commitTo}"/>
                                                <div class="slds-size--1-of-2">
                                                    <apex:inputText size="25" value="{!commitToLabel}" id="branchTargetName" onFocus="this.blur()" disabled="false" html-callitafterchange="refreshOnBranchSelect" styleClass="slds-input slds-text-heading_regular"/> 
                                                </div>
                                                <div class="slds-size--1-of-2">
                                                    <img style="height: 45%;margin-left: 2%;margin-top: 3px;" src="/apexpages/slds/latest/assets/icons/utility/search_60.png" 
                                                        onclick="dlm_openLookupPopup('{!$Component.branchTargetName}','{!$Component.branchTargetId}','{!$ObjectType.Branch__c.Name}',
                                                        '{!$ObjectType.Branch__c.fields.Repository__c.Name} =\'{!selectedRepository}\'');clearMessage(); return false"
                                                        alt="Snapshot Name Lookup (New Window)" />
                                                </div>
                                            </div>
                                    </apex:outputPanel>
                                    <apex:outputPanel styleClass="slds-form-element slds-size--4-of-12 slds-m-bottom_small slds-m-top_small" layout="block" rendered="{!commitList.size > 0 && (commitTo == '' || commitTo == null)}">
                                        <apex:outputLabel styleClass="slds-form-element__label slds-text-heading_regular lbcls" value="Branch Name" />
                                        <div class="slds-form-element__control">
                                            <apex:InputText styleClass="slds-input slds-text-heading_regular" value="{!newBranchName}"/>
                                        </div>
                                    </apex:outputPanel>
                            </apex:outputPanel>
                        </apex:outputPanel>
    
                        <!-- choose the components to commit plus filter functionality -->                  
                        <apex:outputPanel id="FirstPageBlock" layout="block" html-ng-show="CommitStep == 0">
                            <fieldset class="slds-box slds-theme--default">
                                <apex:outputPanel layout="block" styleClass="slds-m-bottom_small slds-m-top_small">
                                    <div class="slds-grid slds-gutters">
                                        <div class="slds-col slds-size_2-of-3">
                                            <h4 class="lbcls slds-m-left_medium">Components</h4>
                                        </div>
                                        <div class="slds-col slds-size_1-of-3">
                                            <a class="slds-float--right slds-m-right_medium" ng-click="showHideComponentList();" style="cursor: pointer;">{{componentListShow ? 'hide':'show'}}</a>
                                        </div>
                                    </div>
                                </apex:outputPanel>
                                          
                                <div class="slds-float--right slds-size--2-of-12" role="group">
                                    <apex:commandbutton value="Cancel" action="{!back}" reRender="msg" id="buttonTwo" styleClass="slds-button slds-button_neutral"/>
                                    <apex:commandButton value="{!$Label.flosum__go_to_commit_button_label}" action="{!goToCommit}" reRender="brOption" oncomplete="getCommitInformation('{!commitTo}','{!orgId}', '{!commitSuccess}', '{!JSENCODE(msg)}');overridePageMessages();" onClick="clearMessage();show();" html-ng-disabled="isLoading" styleClass="slds-button slds-button_neutral"/>
                                </div>
                            
                                
                                <apex:outputPanel styleClass="slds-form-element slds-size--3-of-12 slds-m-bottom_small slds-m-top_small" layout="block" html-ng-show="componentListShow" id="pbs1">
                                    <div class="slds-grid slds-gutters">
                                        <div class="slds-col slds-size_1-of-2">
                                            <div class="slds-select_container">
                                                <apex:selectList value="{!selectedMetadataType}" multiselect="false" style="padding: 3px;" styleClass="slds-select slds-text-heading_regular" id="picklst1" size="1">
                                                    <apex:selectOptions value="{!availableMetatypes}"/>
                                                    <apex:actionSupport event="onchange" action="{!setFilter}"  reRender="tbl,msg" oncomplete="filterList('{!selectedMetadataType}');updateAllChecked();hide();" onsubmit="show();"/>
                                                </apex:selectList>
                                            </div>
                                        </div>
                                        <div class="slds-col slds-size_1-of-2">
                                            <div class="slds-grid slds-m-left--medium">
                                                <input type="text" ng-model="searchText" id="searchField" Class="slds-input slds-text-heading_regular"/>
                                            </div>
                                        </div>
                                    </div>
                                </apex:outputpanel>
                                
                            
                                <table ng-show="componentListPtr.length  > 0 && filtered.length > 0 && componentListShow" class="list slds-table slds-table_bordered slds-table_cell-buffer">
                                    <thead>
                                        <tr class="headerRow">
                                             <th>No.</th>
                                             <th><input type="checkbox" ng-click="checkUncheck((componentListPtr|filter:{compName:searchText}),0);" class="psli" ng-model="isAllChecked0" >&nbsp;</input></th>
                                             <th ng-repeat = "(key, value) in fieldSet0">
                                                <a ng-click="components.refreshOrderBy(key)">{{ components.orderByColumn == key ? components.isReverse ? value+' ▼' : value+' ▲' : value }}</a>
                                             </th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                       <tr ng-repeat = "item in componentListPtr |  filter:{compName:searchText}  |  orderBy: components.orderByColumn : components.isReverse | limitTo: components.viewLimit as filtered" ng-if="$index >= components.metaOffSet" class="dataRow" onmouseover="if (window.hiOn){hiOn(this);} " onmouseout="if (window.hiOff){hiOff(this);} ">
                                            <td>{{ $index+1 }}</td>
                                            <td><input type="checkbox" name="selectedComps[]" value="{{ item['id'] }}" ng-model="item['check']"/></td>
                                            <td ng-repeat = "(key, value) in fieldSet0Vis">
                                                 {{ item[key] }}
                                            </td>
                                        </tr>
                                    </tbody>
                                </table>
                                <apex:outputPanel html-ng-show="componentListPtr.length > 0 && filtered.length > 0 && componentListShow" layout="block" style="text-align: center;" styleClass="btnMargin pagination slds-m-top--medium slds-grid slds-wrap slds-grid--pull-padded">
                                    <div class="slds-col--padded slds-size--1-of-1 slds-medium-size--1-of-2 slds-large-size--1-of-3">
                                        <apex:commandbutton html-ng-click="components.showFirst();" styleClass="btn slds-button slds-button_neutral slds-float_right" onClick="return false;" value="First" reRender="none" html-ng-disabled="components.isPrevious() || disableNextPrevious"/>
                                        <apex:commandbutton html-ng-click="components.listPrevious();" styleClass="btn slds-button slds-button_neutral slds-float_right" onClick="return false;" value="Previous" reRender="none" html-ng-disabled="components.isPrevious() || disableNextPrevious" />
                                    </div>
                                    <div class="slds-col--padded slds-size--1-of-1 slds-medium-size--1-of-2 slds-large-size--1-of-3 paginationStr">
                                        Total {{(componentListPtr|filter:{compName:searchText}).length}} component(s), Page {{components.currentPageNo((componentListPtr|filter:{compName:searchText}).length)}} of {{components.totalPageCount((componentListPtr|filter:{compName:searchText}).length)}}
                                    </div>
                                    <div class="slds-col--padded slds-size--1-of-1 slds-medium-size--1-of-2 slds-large-size--1-of-3">
                                        <apex:commandbutton html-ng-click="components.listNext((componentListPtr|filter:{compName:searchText}).length);" styleClass="btn slds-button slds-button_neutral slds-float_left" onClick="return false;" value="Next" reRender="none" html-ng-disabled="components.isNext((componentListPtr|filter:{compName:searchText}).length) || disableNextPrevious"/>
                                        <apex:commandbutton html-ng-click="components.showLast((componentListPtr|filter:{compName:searchText}).length);" styleClass="btn slds-button slds-button_neutral slds-float_left" onClick="return false;" value="Last" reRender="none" html-ng-disabled="components.isNext((componentListPtr|filter:{compName:searchText}).length) || disableNextPrevious"/>
                                    </div>
                                </apex:outputPanel>
                                <div style="width: 100%;float: center; padding: 5px;text-align: center;" ng-show="(componentListPtr.length == 0 || filtered.length == 0) && componentListShow">
                                      <strong>No records to display</strong>
                                </div>
                            </fieldset>
                        </apex:outputPanel>
                
                        <!-- choose (2nd step) the components to commit  -->                
                        <apex:outputPanel id="SecondPageBlock" layout="block" html-ng-show="CommitStep == 1">
                            <div class="slds-grid slds-gutters">
                                <div class="slds-col slds-float--left slds-m-top_small slds-m-bottom_small slds-m-left_medium">
                                    <apex:commandButton styleClass="slds-button slds-button_neutral" value="Back To Snapshot" action="{!backToSnap}" reRender="msg,tbl,pbsi1" onClick="show();" onComplete="gotoPreviousPage();hide();overridePageMessages();"/>
                                    <apex:commandButton styleClass="slds-button slds-button_neutral" value="{!$Label.flosum__go_to_commit_button_label}" action="{!snapCommit}" reRender="tbl" onClick="show();" onComplete="finalCommit({!commitSuccess},'{!logId}','{!commitTo}');overridePageMessages();" html-ng-disabled="isEmpty();"/>
                                </div>
                            </div>
                            <!-- conflicted components   -->                
                            <apex:outputPanel layout="block" styleClass="slds-m-top_small">
                                <apex:outputPanel layout="block" styleClass="slds-box slds-theme--default slds-container">
                                    <div class="slds-section__title ">
                                        <h3 class="slds-section__title-action">
                                            <div class="slds-icon" >
                                                <img style="height:20px" id="changeMe" src="{!URLFOR($Asset.SLDS, 'assets/icons/utility/switch_60.png')}" />
                                            </div>
                                            {!$Label.Conflict_Components_Section_Title}
                                            <div class="slds-m-left_xx-small mouseOverInfoOuter" id="searchInvoiceHelper" onfocus="addMouseOver(this)" onmouseover="addMouseOver(this)" tabindex="0">
                                                <img src="/s.gif" alt="" class="infoIcon" title="" />
                                                <div class="mouseOverInfo" id="searchInvoiceHelperText" style="display: none; opacity: -0.19999999999999996; left: 16px;">
                                                    <div class="body">{!$Label.conflict_components_section_description}<b>{!$Label.conflict_components_section_description_2}</b></div>
                                                </div>
                                            </div>
                                            <div class="slds-col">
                                                <a class="slds-float--right slds-m-right_medium" ng-click="showHideConflictComponentList();" style="cursor: pointer;">{{componentShow ? 'hide':'show'}}</a>
                                            </div>      
                                        </h3>
                                    </div>
                                    <div class="slds-border_left slds-border_bottom slds-border_top slds-border_right">
                                        <table ng-show="componentList.length > 0 && componentShow" class="list slds-table slds-table_bordered slds-table_cell-buffer">
                                            <thead>
                                                <tr class="headerRow">
                                                     <th>No.</th>
                                                     <th><input type="checkbox" ng-click="checkUncheck(componentList,1);" class="psli" ng-model="isAllChecked1" >&nbsp;</input></th>
                                                     <th ng-repeat = "(key, value) in fieldSet0">
                                                        <a ng-click="conflictComp.refreshOrderBy(key)">{{ conflictComp.orderByColumn == key ? conflictComp.isReverse ? value+' ▼' : value+' ▲' : value }}</a>
                                                     </th>
                                                     <th>Compare</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                               <tr ng-repeat = "item in componentList |  orderBy: conflictComp.orderByColumn : conflictComp.isReverse | limitTo: conflictComp.viewLimit" ng-if="$index >= conflictComp.metaOffSet" class="dataRow" onmouseover="if (window.hiOn){hiOn(this);} " onmouseout="if (window.hiOff){hiOff(this);} ">
                                                    <td>{{ $index+1 }}</td>
                                                    <td><input type="checkbox" name="selectedComps1[]" value="{{ item['id'] }}" ng-model="item['check']"/></td>
                                                    <td ng-repeat = "(key, value) in fieldSet0Vis">
                                                         {{ item[key] }}
                                                    </td>
                                                    <td>
                                                         <span style="cursor: pointer; color:red" ng-click="openComparison(item);" ng-show="item.conflict">Conflict</span>
                                                    </td> 
                                                </tr>
                                            </tbody>
                                        </table>
                                        <apex:outputPanel html-ng-show="componentList.length > 0 && componentShow" layout="block" style="text-align: center;" styleClass="btnMargin pagination slds-m-top--medium slds-grid slds-wrap slds-grid--pull-padded">
                                            <div class="slds-col--padded slds-size--1-of-1 slds-medium-size--1-of-2 slds-large-size--1-of-3">
                                                <apex:commandbutton html-ng-click="conflictComp.showFirst();" styleClass="btn slds-button slds-button_neutral slds-float_right" onClick="return false;" value="First" reRender="none" html-ng-disabled="conflictComp.isPrevious() || disableNextPrevious"/>
                                                <apex:commandbutton html-ng-click="conflictComp.listPrevious();" styleClass="btn slds-button slds-button_neutral slds-float_right" onClick="return false;" value="Previous" reRender="none" html-ng-disabled="conflictComp.isPrevious() || disableNextPrevious" />
                                            </div>
                                            <div class="slds-col--padded slds-size--1-of-1 slds-medium-size--1-of-2 slds-large-size--1-of-3 paginationStr">
                                                Total {{(componentList).length}} component(s), Page {{conflictComp.currentPageNo((componentList).length)}} of {{conflictComp.totalPageCount((componentList).length)}}
                                            </div>
                                            <div class="slds-col--padded slds-size--1-of-1 slds-medium-size--1-of-2 slds-large-size--1-of-3">
                                                <apex:commandbutton html-ng-click="conflictComp.listNext((componentList).length);" styleClass="btn slds-button slds-button_neutral slds-float_left" onClick="return false;" value="Next" reRender="none" html-ng-disabled="conflictComp.isNext((componentList).length) || disableNextPrevious"/>
                                                <apex:commandbutton html-ng-click="conflictComp.showLast((componentList).length);" styleClass="btn slds-button slds-button_neutral slds-float_left" onClick="return false;" value="Last" reRender="none" html-ng-disabled="conflictComp.isNext((componentList).length) || disableNextPrevious"/>
                                            </div>
                                        </apex:outputPanel>
                                        <div style="width: 100%;float: center; padding: 5px;text-align: center;" ng-show="componentList.length == 0 && componentShow">
                                              <strong>No records to display</strong>
                                        </div>
                                    </div>
                                </apex:outputPanel>
                            </apex:outputPanel>
                            <!-- safe components   -->                  
                            <apex:outputPanel layout="block" styleClass="slds-m-top_small">
                                <apex:outputPanel layout="block" styleClass="slds-box slds-theme--default slds-container">
                                    <div class="slds-section__title ">
                                        <h3 class="slds-section__title-action">
                                            <div class="slds-icon" >
                                                <img style="height:20px" id="changeMe" src="{!URLFOR($Asset.SLDS, 'assets/icons/utility/switch_60.png')}" />
                                            </div>
                                            {!$Label.Safe_To_Commit_Section_Title}
                                            <div class="slds-m-left_xx-small mouseOverInfoOuter" id="searchInvoiceHelper" onfocus="addMouseOver(this)" onmouseover="addMouseOver(this)" tabindex="0">
                                                <img src="/s.gif" alt="" class="infoIcon" title="" />
                                                <div class="mouseOverInfo" id="searchInvoiceHelperText" style="display: none; opacity: -0.19999999999999996; left: 16px;">
                                                    <div class="body">{!$Label.safe_to_commit_section_description}</div>
                                                </div>
                                            </div>
                                            <div class="slds-col">
                                                <a class="slds-float--right slds-m-right_medium" ng-click="showHideSafeComponentList();" style="cursor: pointer;">{{newCompShow ? 'hide':'show'}}</a>
                                            </div>     
                                        </h3>
                                    </div>
                                    <div class="slds-border_left slds-border_bottom slds-border_top slds-border_right">
                                        <table ng-show="newCompList.length > 0 && newCompShow" class="list slds-table slds-table_bordered slds-table_cell-buffer">
                                            <thead>
                                                <tr class="headerRow">
                                                     <th>No.</th>
                                                     <th><input type="checkbox" ng-click="checkUncheck(newCompList,2);" class="psli" ng-model="isAllChecked2" >&nbsp;</input></th>
                                                     <th ng-repeat = "(key, value) in fieldSet0">
                                                        <a ng-click="newComp.refreshOrderBy(key)">{{ newComp.orderByColumn == key ? newComp.isReverse ? value+' ▼' : value+' ▲' : value }}</a>
                                                     </th>
                                                     <th>Compare</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                               <tr ng-repeat = "item in newCompList |  orderBy: newComp.orderByColumn : newComp.isReverse | limitTo: newComp.viewLimit" ng-if="$index >= newComp.metaOffSet" class="dataRow" onmouseover="if (window.hiOn){hiOn(this);} " onmouseout="if (window.hiOff){hiOff(this);} ">
                                                    <td>{{ $index+1 }}</td>
                                                    <td><input type="checkbox" name="selectedComps2[]" value="{{ item['id'] }}" ng-model="item['check']"/></td>
                                                    <td ng-repeat = "(key, value) in fieldSet0Vis">
                                                         {{ item[key] }}
                                                    </td>
                                                    <td>
                                                         <span style="cursor: pointer; color:green" ng-click="openComparison(item);" ng-show="item.conflict && item.conflict != '0'">Autoresolved</span>
                                                    </td> 
                                                </tr>
                                            </tbody>
                                        </table>
                                    
                                        <apex:outputPanel html-ng-show="newCompList.length > 0 && newCompShow" layout="block" style="text-align: center;" styleClass="btnMargin pagination slds-m-top--medium slds-grid slds-wrap slds-grid--pull-padded">
                                            <div class="slds-col--padded slds-size--1-of-1 slds-medium-size--1-of-2 slds-large-size--1-of-3">
                                                <apex:commandbutton html-ng-click="newComp.showFirst();" styleClass="btn slds-button slds-button_neutral slds-float_right" onClick="return false;" value="First" reRender="none" html-ng-disabled="newComp.isPrevious() || disableNextPrevious"/>
                                                <apex:commandbutton html-ng-click="newComp.listPrevious();" styleClass="btn slds-button slds-button_neutral slds-float_right" onClick="return false;" value="Previous" reRender="none" html-ng-disabled="newComp.isPrevious() || disableNextPrevious" />
                                            </div>
                                            <div class="slds-col--padded slds-size--1-of-1 slds-medium-size--1-of-2 slds-large-size--1-of-3 paginationStr">
                                                Total {{(newCompList).length}} component(s), Page {{newComp.currentPageNo((newCompList).length)}} of {{newComp.totalPageCount((newCompList).length)}}
                                            </div>
                                            <div class="slds-col--padded slds-size--1-of-1 slds-medium-size--1-of-2 slds-large-size--1-of-3">
                                                <apex:commandbutton html-ng-click="newComp.listNext((newCompList).length);" styleClass="btn slds-button slds-button_neutral slds-float_left" onClick="return false;" value="Next" reRender="none" html-ng-disabled="newComp.isNext((newCompList).length) || disableNextPrevious"/>
                                                <apex:commandbutton html-ng-click="newComp.showLast((newCompList).length);" styleClass="btn slds-button slds-button_neutral slds-float_left" onClick="return false;" value="Last" reRender="none" html-ng-disabled="newComp.isNext((newCompList).length) || disableNextPrevious"/>
                                            </div>
                                        </apex:outputPanel>
                                    
                                        <div style="width: 100%;float: center; padding: 5px;text-align: center;" ng-show="newCompList.length == 0 && newCompShow">
                                              <strong>No records to display</strong>
                                        </div>
                                    </div>
                                </apex:outputPanel>
                            </apex:outputPanel>
    
                            <!-- not committed components   -->                 
                            <apex:outputPanel layout="block" styleClass="slds-m-top_small">
                                <apex:outputPanel layout="block" styleClass="slds-box slds-theme--default slds-container">
                                    <div class="slds-section__title ">
                                        <h3 class="slds-section__title-action">
                                            <div class="slds-icon" >
                                                <img style="height:20px" id="changeMe" src="{!URLFOR($Asset.SLDS, 'assets/icons/utility/switch_60.png')}" />
                                            </div>
                                            {!$Label.Not_Merge_Section_Title}
                                            <div class="slds-m-left_xx-small mouseOverInfoOuter" id="searchInvoiceHelper" onfocus="addMouseOver(this)" onmouseover="addMouseOver(this)" tabindex="0">
                                                <img src="/s.gif" alt="" class="infoIcon" title="" />
                                                <div class="mouseOverInfo" id="searchInvoiceHelperText" style="display: none; opacity: -0.19999999999999996; left: 16px;">
                                                    <div class="body">{!$Label.not_merge_section_description}</div>
                                                </div>
                                            </div>
                                            <div class="slds-col">
                                                <a class="slds-float--right slds-m-right_medium" ng-click="showHideNotCommitComponentList();" style="cursor: pointer;">{{notMergeCompShow ? 'hide':'show'}}</a>
                                            </div>     
                                        </h3>
                                    </div>
                                    <div class="slds-border_left slds-border_bottom slds-border_top slds-border_right">
                                        <table ng-show="notMergeCompList.length > 0 && notMergeCompShow" class="list slds-table slds-table_bordered slds-table_cell-buffer">
                                            <thead>
                                                <tr class="headerRow">
                                                     <th>No.</th>
                                                     <th><input type="checkbox" ng-click="checkUncheck(notMergeCompList,3);" class="psli" ng-model="isAllChecked3" >&nbsp;Overwrite</input></th>
                                                     <th ng-repeat = "(key, value) in fieldSet1">
                                                        <a ng-click="notMergeComp.refreshOrderBy(key)">{{ notMergeComp.orderByColumn == key ? notMergeComp.isReverse ? value+' ▼' : value+' ▲' : value }}</a>
                                                     </th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                               <tr ng-repeat = "item in notMergeCompList |  orderBy: notMergeComp.orderByColumn : notMergeComp.isReverse | limitTo: notMergeComp.viewLimit" ng-if="$index >= notMergeComp.metaOffSet" class="dataRow" onmouseover="if (window.hiOn){hiOn(this);} " onmouseout="if (window.hiOff){hiOff(this);} ">
                                                    <td>{{ $index+1 }}</td>
                                                    <td><input type="checkbox" name="selectedComps3[]" value="{{ item['id'] }}" ng-model="item['check']"/></td>
                                                    <td ng-repeat = "(key, value) in fieldSet1Vis">
                                                         {{ item[key] }}
                                                    </td>
                                                </tr>
                                            </tbody>
                                        </table>
                                        <apex:outputPanel html-ng-show="notMergeCompList.length > 0 && notMergeCompShow" layout="block" style="text-align: center;" styleClass="btnMargin pagination slds-m-top--medium slds-grid slds-wrap slds-grid--pull-padded">
                                            <div class="slds-col--padded slds-size--1-of-1 slds-medium-size--1-of-2 slds-large-size--1-of-3">
                                                <apex:commandbutton html-ng-click="notMergeComp.showFirst();" styleClass="btn slds-button slds-button_neutral slds-float_right" onClick="return false;" value="First" reRender="none" html-ng-disabled="notMergeComp.isPrevious() || disableNextPrevious"/>
                                                <apex:commandbutton html-ng-click="notMergeComp.listPrevious();" styleClass="btn slds-button slds-button_neutral slds-float_right" onClick="return false;" value="Previous" reRender="none" html-ng-disabled="notMergeComp.isPrevious() || disableNextPrevious" />
                                            </div>
                                            <div class="slds-col--padded slds-size--1-of-1 slds-medium-size--1-of-2 slds-large-size--1-of-3 paginationStr">
                                                Total {{(notMergeCompList).length}} component(s), Page {{notMergeComp.currentPageNo((notMergeCompList).length)}} of {{notMergeComp.totalPageCount((notMergeCompList).length)}}
                                            </div>
                                            <div class="slds-col--padded slds-size--1-of-1 slds-medium-size--1-of-2 slds-large-size--1-of-3">
                                                <apex:commandbutton html-ng-click="notMergeComp.listNext((notMergeCompList).length);" styleClass="btn slds-button slds-button_neutral slds-float_left" onClick="return false;" value="Next" reRender="none" html-ng-disabled="notMergeComp.isNext((notMergeCompList).length) || disableNextPrevious"/>
                                                <apex:commandbutton html-ng-click="notMergeComp.showLast((notMergeCompList).length);" styleClass="btn slds-button slds-button_neutral slds-float_left" onClick="return false;" value="Last" reRender="none" html-ng-disabled="notMergeComp.isNext((notMergeCompList).length) || disableNextPrevious"/>
                                            </div>
                                        </apex:outputPanel>
                                        <div style="width: 100%;float: center; padding: 5px;text-align: center;" ng-show="notMergeCompList.length == 0 && notMergeCompShow">
                                              <strong>No records to display</strong>
                                        </div>
                                    </div>
                                </apex:outputPanel>
                            </apex:outputPanel>
                        </apex:outputPanel>
                    </div>
                </div>
            </div>
        </apex:form>
    </apex:outputPanel>
    

    <script>
        $( document ).ready(function() {
            overridePageMessages();
        });
        
        const locale = '{!locale}';
        const timezone = '{!timezone}';
        
 
        if(typeof jQuery != 'undefined'){
             $j =jQuery.noConflict();
        }
        
        function getDate(jsonDate){
            try{
                if (locale && timezone){
                    return new Date(jsonDate).toLocaleString(locale, { timeZone: timezone })
                }
            }catch(e){}
            return new Date(jsonDate).toUTCString();
        }
    
    function correctDate(list){
        for (var i = 0; i< list.length; i++ ){
            var jsonDate = list[i].changedOn;
            if (jsonDate != undefined){
                list[i].changedOnTxt = getDate(jsonDate);
            }
        }
    }
    
    var nSelected = 0;
    
/*
    function goToSecondPage(){
        nSelected = getScope().initialSelectionSet0.length;
        ////console.log('call goToSecondpage with param = '+nSelected);
        goToCommit(nSelected);
    }
*/    
    function gotoPreviousPage(){
        ////////console.log('gotoPreviousPage');
        getScope().CommitStep = 0;
        getScope().initialize();
    }
    
    function filterList(val){
        ////////console.log('filterList:'+val);
        getScope().typeFilter = val;
        getScope().applyFilter();
    }
    
    function updateAllChecked(){
        getScope().updateAccumulator();
    }
    
    
        
        
        const ZIPPACK_LIMIT = 2500000;
        const xmlName = 'package.xml';
        const apiVersion = {!localApiVersion};
        var sessionId = "{!$Api.Session_Id}";

        Visualforce.remoting.timeout = 120000;
        var totalRecords = 0;
        var NameSpacePrefix = '{!NameSpacePrefix}';

        zip.workerScripts = {
            deflater: ['res/js/workers/z-worker.js', 'res/js/workers/deflate.js'],
            inflater: ['res/js/workers/z-worker.js', 'res/js/workers/inflate.js']
        };
        
        zip.useWebWorkers = false;
        
        var zipWriter, writer, creationMethod, URL = window.webkitURL || window.mozURL || window.URL;
        
        var attList = [];
        var metaItemList = [];
        var metaFoundMap = {};
        var fileMap = {};
        var auraFileMap = {};
        var allCompMap = {};
        var allCompFilter = {};
        var allCompTypeFilter = {};
        var normalZip = new JSZip(); 
        var ComponentAttachmentWraperList = [];
        var isPatchCreated = false; 
        
        var parentMap = {};
        parentMap['Workflow'] = 'Workflow';
        parentMap['CustomObject'] = 'CustomObject';
        parentMap['CustomLabels'] = 'CustomLabels';
        parentMap['AssignmentRules'] = 'AssignmentRules';
        parentMap['AutoResponseRules'] = 'AutoResponseRules';
        parentMap['MatchingRules'] = 'MatchingRules';
        parentMap['ManagedTopics'] = 'ManagedTopics';
        parentMap['EscalationRules'] = 'EscalationRules';
        parentMap['Package-xml'] = 'Package-xml';
        
        
        var mmap = new Object();
        mmap['CustomField'] = true;
        mmap['CustomLabel'] = true;
        mmap['CompactLayout'] = true;
        mmap['WebLink'] = true;
        mmap['RecordType'] = true;
        mmap['ListView'] = true;
        mmap['FieldSet'] = true;
        mmap['AssignmentRule'] = true;
        mmap['AutoResponseRule'] = true;
        mmap['ValidationRule'] = true;
        mmap['WorkflowTask'] = true;
        mmap['WorkflowOutboundMessage'] = true;
        mmap['WorkflowFieldUpdate'] = true;
        mmap['WorkflowKnowledgePublish'] = true;
        mmap['WorkflowAlert'] = true;
        mmap['WorkflowRule'] = true;
        
        mmap['SharingOwnerRule'] = true;
        mmap['SharingCriteriaRule'] = true;
        mmap['BusinessProcess'] = true;
        mmap['SharingReason'] = true;
        mmap['EscalationRule'] = true;
        mmap['MatchingRule'] = true;
        mmap['ManagedTopic'] = true;
        
        var folderMap = new Object();
        folderMap['DocumentFolder'] = 'Document';
        folderMap['DashboardFolder'] = 'Dashboard';
        folderMap['ReportFolder'] = 'Report';
        folderMap['EmailFolder'] = 'EmailTemplate';

        var revFolderMap = new Object();
        revFolderMap['Document'] = true;
        revFolderMap['Dashboard'] = true;
        revFolderMap['Report'] = true;
        revFolderMap['EmailTemplate'] = true;
        
        var bundleTypes = {};
        bundleTypes['AuraDefinitionBundle'] = 'AuraDefinitionBundle';
        bundleTypes['LightningComponentBundle'] = 'LightningComponentBundle';
        
        
        function showErrorMessage(str)
    {
        if($j('#msg') != undefined)
        {
            $j('#msg').remove();
        }
        var parentVal = $j("[id$='msg']");
        if(parentVal != undefined)
        {
            var childVal = '<span id="msg">'+
                            '<span>'+
                                '<div class="message errorM3" role="alert">'+
                                    '<table border="0" cellpadding="0" cellspacing="0" class="messageTable" style="padding:0px;margin:0px;">'+
                                        '<tbody>'+
                                            '<tr valign="top">'+
                                            '<td>'+
                                                '<img alt="ERROR" class="msgIcon" src="/s.gif" title="ERROR">'+
                                            '</td>'+
                                            '<td class="messageCell">'+
                                                '<div class="messageText" >'+
                                                    '<span style="color:#cc0000">'+
                                                        '<h4>Error:</h4>'+
                                                    '</span>'+
                                                    '<span style="color:#000000">'+
                                                       str+
                                                    '</span>'+ 
                                                    '<br>'+
                                                '</div>'+
                                            '</td>'+
                                            '</tr>'+
                                            '<tr>'+
                                                '<td></td>'+
                                                '<td></td>'+
                                            '</tr>'+
                                        '</tbody>'+
                                    '</table>'+
                                '</div>'+
                            '</span>'+
                        '</span>';
             parentVal.before(childVal);
        }
        unbindWindow();
    }
        

        var commitIds, bodySize, componentMetaMap, metaIds, fileIndex, commitSuccess, branchId, componentMetaMap, currentIndex, buildLogId;
        
            /******             angularJs modules description               ******/
    
        var myApp = angular.module("snapCommit", ['base64']);
        
        myApp.$inject = ['$scope', '$filter', '$controller'];
        
        myApp.service('dataManager', function($q) {
            return {
                getAllItems : function() {
                    var deferred = $q.defer();
                    var snapId = '{!orgId}';
                    if (snapId == undefined || snapId == ''){
                        snapId = '';
                    }
                    Visualforce.remoting.Manager.invokeAction(
                        '{!$RemoteAction.OrgComponentToBranchCommitController.getAllItems}',
                        snapId,
                        function(result, event) {
                            if (event.status) {
                                deferred.resolve(result);
                            }
                            else {
                                deferred.reject(event);
                            }
                        });
                    
                    return deferred.promise;
                },
                getItems : function(list) {
                    var deferred = $q.defer();
                    var snapId = '{!orgId}';
                    if (snapId == undefined || snapId == ''){
                        snapId = '';
                    }
                    Visualforce.remoting.Manager.invokeAction(
                        '{!$RemoteAction.OrgComponentToBranchCommitController.getItems}',
                        snapId,
                        JSON.stringify(list),
                        function(result, event) {
                            if (event.status) {
                                deferred.resolve(result);
                            }
                            else {
                                deferred.reject(event);
                            }
                        });
                    
                    return deferred.promise;
                },
                getComparison : function(list) {
                    var deferred = $q.defer();
                    ////////console.log('br='+branchRef);
                    ////////console.log('snapId='+snapRef);
                    Visualforce.remoting.Manager.invokeAction(
                        '{!$RemoteAction.OrgComponentToBranchCommitController.getComparison}',
                        snapRef,
                        branchRef,
                        JSON.stringify(list),
                        function(result, event) {
                            if (event.status) {
                                deferred.resolve(result);
                            }
                            else {
                                deferred.reject(event);
                            }
                        });
                    
                    return deferred.promise;
                }
                
            }
        });
        
           myApp.directive('postrenderAction', postrenderAction); 

        /* @ngInject */
        function postrenderAction($timeout) {
            // Directive Interface
            // Defines base properties for the directive.
            var directive = {
                restrict: 'A',
                priority: 101,
                link: link
            };
            return directive;

            // Link Function
            // Provides functionality for the directive during the DOM building/data binding stage.
            function link(scope, element, attrs) {
                $timeout(function() {
                    scope.$evalAsync(attrs.postrenderAction);
                }, 0);
            }
        }
        
        
        var app = myApp.controller("Snap2BranchCommitControllerAJS", function($scope, $base64, $controller, dataManager,$filter,  $interval, $timeout, filterFilter) {
            $scope.componentBaseList = [];
            $scope.componentListPtr = [];
            
            $scope.componentList = []; // type ConflictWrapper
            $scope.newCompList = []; // type SafeCommitCompWrapper
            $scope.notMergeCompList = []; // type NotCommitCompWrapper
            
            $scope.attIdMap = {};
            $scope.globalAttIdMap = {};
            
            $scope.componentListShow = true;
            $scope.componentShow = true;
            $scope.newCompShow = true;
            $scope.notMergeCompShow = true;
            
            $scope.components = new Page({orderByColumn:'changedOn', isReverse: true});
            $scope.conflictComp = new Page({orderByColumn:'compName', isReverse: true});
            $scope.newComp = new Page({orderByColumn:'compName', isReverse: true});
            $scope.notMergeComp = new Page({orderByColumn:'compName', isReverse: true});
            
            var tempObj0 = {};
            tempObj0['compName'] = 'Component Name';
            tempObj0['compType'] = 'Component Type';
            tempObj0['changedBy'] = 'Changed By';
            tempObj0['changedOn'] = 'Changed On';
            $scope.fieldSet0 = tempObj0;
            var tempObj0Vis = {};
            tempObj0Vis['compName'] = 'Component Name';
            tempObj0Vis['compType'] = 'Component Type';
            tempObj0Vis['changedBy'] = 'Changed By';
            tempObj0Vis['changedOnTxt'] = 'Changed On';
            $scope.fieldSet0Vis = tempObj0Vis;
            $scope.initialSelectionSet0 = [];
            $scope.isAllChecked0 = false;

            var tempObj1 = {};
            tempObj1['compName'] = 'Component Name';
            tempObj1['compType'] = 'Component Type';
            tempObj1['changedBy'] = 'Changed By';
            tempObj1['changedOn'] = 'Changed On';
            tempObj1['reason'] = 'Reason';
            $scope.fieldSet1 = tempObj1;
            var tempObj1Vis = {};
            tempObj1Vis['compName'] = 'Component Name';
            tempObj1Vis['compType'] = 'Component Type';
            tempObj1Vis['changedBy'] = 'Changed By';
            tempObj1Vis['changedOnTxT'] = 'Changed On';
            tempObj1Vis['reason'] = 'Reason';
            $scope.fieldSet1Vis = tempObj1Vis;
            $scope.selectionSet1 = [];
            $scope.selectionSet2 = [];
            $scope.selectionSet3 = [];
            $scope.isAllChecked1 = false;
            $scope.isAllChecked2 = false;
            $scope.isAllChecked3 = false;
            
            $scope.isLoading = false;
            $scope.CommitStep = 0;
            $scope.typeFilter = 'all';
            
            
            $scope.updateAccumulator = function(){
                $scope.isAllChecked0 = false;
            }

            $scope.openComparison = function(item){
                var base = '{!baseUrl}';
                if (base){
                    var link = base + '?fromMerge=fromLatestCommit&branchCompHisId=' + item.conflict + '&metaId=' + item.id; 
                    var w = window.open(link, '_blank');
                }
            }
            
                          // Watch componentList for changes
            $scope.$watch('componentBaseList|filter:{check:true}', function (nv) {
                $scope.initialSelectionSet0 = nv.map(function (c) {
                    return c.id;
                });
            }, true);
            $scope.$watch('componentList|filter:{check:true}', function (nv) {
                $scope.selectionSet1 = nv.map(function (c) {
                    return c.id;
                });
            }, true);
            $scope.$watch('newCompList|filter:{check:true}', function (nv) {
                $scope.selectionSet2 = nv.map(function (c) {
                    return c.id;
                });
            }, true);
            $scope.$watch('notMergeCompList|filter:{check:true}', function (nv) {
                $scope.selectionSet3 = nv.map(function (c) {
                    return c.id;
                });
            }, true);
            
            $scope.getCommitSet = function(){
                var a1 = $scope.selectionSet1.concat($scope.selectionSet2);
                var a2 = $scope.selectionSet3.concat(a1);
                return a2;
            }
            
            
            $scope.checkUncheck = function(compLi,nList) {
                if (nList == 0){
                    setAll(compLi,$scope.isAllChecked0); 
                }else if (nList == 1){
                    setAll(compLi,$scope.isAllChecked1); 
                }else if (nList == 2){
                    setAll(compLi,$scope.isAllChecked2); 
                }else if (nList == 3){
                    setAll(compLi,$scope.isAllChecked3); 
                }else{
                    $scope.isAllChecked0 = false; 
                    $scope.isAllChecked1 = false;
                    $scope.isAllChecked2 = false;
                    $scope.isAllChecked3 = false;
                    setAll(compLi,false);
                }   

            };
             
            $scope.isEmpty = function(){
                return ($scope.selectionSet1.length == 0 && $scope.selectionSet2.length == 0 && $scope.selectionSet3.length == 0);
            }
            
            
             $scope.showHideConflictComponentList = function(){
                $timeout(function() {
                       $scope.componentShow = ($scope.componentShow)? false:true;
                });
            }
  
             $scope.showHideSafeComponentList = function(){
                $timeout(function() {
                       $scope.newCompShow = ($scope.newCompShow)? false:true;
                });
            }
  
             $scope.showHideNotCommitComponentList = function(){
                $timeout(function() {
                       $scope.notMergeCompShow = ($scope.notMergeCompShow)? false:true;
                });
            }
             
            
            $scope.showHideComponentList = function(){
                $timeout(function() {
                       $scope.componentListShow = ($scope.componentListShow)? false:true;
                });
            }
            
            var left_to_resolve = 0;
            
            $scope.loadData = function(blockList,callback){
                if (blockList != undefined && blockList.length > 0){
                    var block = blockList.shift();
                    dataManager.getItems(block).then(
                        function (data) {
                            if (data != null && data != undefined && data.items != undefined &&  data.items.length > 0){
                                $scope.componentBaseList = $scope.componentBaseList.concat(data.items);
                                mergeAttIds(data.attIdsMap);
                                $timeout(function() {
                                    $scope.loadData(blockList,callback);
                                });
                            }else{
                                setMessageOnPage('Changes in Flosum\'s database were detected: please reload the page');
                                overridePageMessages();
                            }   
                        },
                        function (error) {
                            showErrorMessage('Error:'+error);
                            $scope.isLoading = false;
                        }
                    );
                }else{
                    left_to_resolve = 0;
                    if (callback != undefined){
                        callback();
                    }
                }
                
                function mergeAttIds(attIdsMap){
                    if (attIdsMap != undefined){
                        var attIdsSet = Object.keys(attIdsMap);
                        for (var x = 0; x < attIdsSet.length; x++){
                            $scope.globalAttIdMap[attIdsSet[x]] = attIdsMap[attIdsSet[x]];
                        }
                    }
                }
            };
            
            $scope.compareData = function(blockList,callback){
                ////console.log('compareData: block: '+blockList.length);
                if (blockList != undefined && blockList.length > 0){
                    var block = blockList.shift();
                    dataManager.getComparison(block).then(
                        function (data) {
                            if (data != null && data != undefined){
                                if (data.msg == ''){
                                    updateLists(data);
                                    setTimeout(function(){
                                        $scope.compareData(blockList,callback);
                                    },10);
                                }else{
                                    showErrorMessage('Error:'+ ((data.msg == undefined || data.msg == '') ? 'Unknown error' : data.msg) );
                                }
                            }else{
                                setMessageOnPage('Changes in Flosum\'s database were detected: please reload the page');
                                overridePageMessages();
                            }   
                        },
                        function (error) {
                            showErrorMessage('Error:'+error);
                            $scope.isLoading = false;
                            hide();
                        }
                    );
                }else{
                    left_to_resolve = 0;
                    if (callback != undefined){
                        callback();
                    }else{
                        //////console.log('callback is null!');
                        $scope.isLoading = false;
                        hide();
                    }
                }

                
                function isEmpty(o){
                    if (o && Object.keys(o).length > 0) return false;
                    return true;
                }
                
                function updateLists(result){
                    if (isEmpty(result.conflictCommit) == false){
                        populateArray($scope.componentList,result.conflictCommit,'Conflict');
                    }
                    if (isEmpty(result.safeCommit) == false){
                        populateArray($scope.newCompList,result.safeCommit,'Safe');
                    }
                    if (result.notCommit.length > 0){
                        populateArray($scope.notMergeCompList,result.notCommit,'None');
                    }
                }
                
                function populateArray(dst,metasrc,type){
                    if (type == 'Conflict' || type == 'Safe'){
                        var src = Object.keys(metasrc);
                        for (var x = 0; x < src.length; x++){
                            var c = selectedCompMap[src[x]];
                            if (c != undefined){
                                c.check = false;// can be false (optional)
                                if (metasrc[src[x]] != '0'){
                                    c.conflict = metasrc[src[x]];
                                }
                                dst.push(c);
                            }
                        }
                    }else if (type == 'None'){
                        var src = metasrc;
                        for (var x = 0; x < src.length; x++){
                            var sourceComp = src[x];
                            var notC = selectedCompMap[sourceComp.id];
                            if (notC != undefined){
                                var reasonTextA = 'The same as Version ';
                                var reasonTextB = ' in Branch';
                                if (sourceComp.isFromRepository == true || sourceComp.isFromRepository == 'true'){
                                    reasonTextB = ' in Repository'; 
                                }
                                notC.reason = 'N/A';
                                if (sourceComp.sameToVersion != undefined){
                                    notC.reason = reasonTextA + sourceComp.sameToVersion + reasonTextB;
                                }
                                notC.check = false;
                                dst.push(notC);
                            }
                        }
                    }
                }
            };

            const BLOCKSIZE = 3000;
            // invoked only when $scope.initialSelectionSet0 list is not empty
            $scope.secondStageCommit = function(){
                // init maps and vars
                allCompMap = {};
                allCompFilter = {};
                $scope.componentList = []; // type ConflictWrapper
                $scope.newCompList = []; // type SafeCommitCompWrapper
                $scope.notMergeCompList = []; // type NotCommitCompWrapper
                // change layout
                console.log('before.',$scope.CommitStep);
                console.log('changing Commit step value.');
                $scope.CommitStep = 1;
                console.log('after.',$scope.CommitStep);
                // set message
                setMessageOnPage('Compare with branch...');
                overridePageMessages();
                
                var commitMap = {};
                for (var x = 0; x < $scope.initialSelectionSet0.length; x++){
                    commitMap[$scope.initialSelectionSet0[x]] = true;
                }
                
                //create a map
                for (var x = 0; x < $scope.componentBaseList.length; x++){
                    var comp =  $scope.componentBaseList[x];
                    if (commitMap[comp.id] != undefined){
                        allCompMap[comp.id] = comp;//allCompMap must contain only components to commit
                        allCompFilter[comp.fileName] = true;
                        var compType = comp.compType;
                        if (folderMap[compType] != undefined){// re-map folders
                            compType = folderMap[comp.compType];
                        }
                        if (allCompTypeFilter[compType] == undefined){
                            allCompTypeFilter[compType] = true;
                        }
                        var attId = $scope.globalAttIdMap[comp.id];
                        if (attId != undefined && $scope.attIdMap[attId] == undefined){
                            $scope.attIdMap[attId] = true;
                        }
                    }
                }
                
                
                
                $scope.globalAttIdMap = {};
                // create  a list of selected types  and list of ids to get Attachments
                var request = new Object();
                request.attIds = Object.keys($scope.attIdMap);
                getSnapshotAttachmentsInfo(request.attIds);
            }
            
            var selectedCompMap = {};
            
            $scope.updateMetaData = function(){

                    selectedCompMap = {};
                    var metaCrcMap = {};
                    var isFound = false;
                    for(var i = 0; i < $scope.initialSelectionSet0.length; i++)
                    {
                        var id = $scope.initialSelectionSet0[i];
                        if(allCompMap[id] != undefined)
                        {
                            var meta = allCompMap[id];
                            var API_Name = meta.compName;
                            var File_Name  = meta.fileName;
                            var MetaType = meta.compType;
                            var metId = meta.id;
                            var key = '';
                            if(mmap[MetaType] == undefined)
                            {
                                if(folderMap[MetaType] != undefined)
                                {
                                    key = folderMap[MetaType]+"#"+File_Name;
                                }
                                else
                                {
                                    key = MetaType+"#"+File_Name;
                                }
                            }
                            else
                            {
                                key = MetaType+"#"+API_Name;
                            }
                            //console.log('key--'+key);
                            if(fileMap[key] != undefined && metId != undefined)
                            {
                                var tempMeta = new Object();
                                tempMeta.Id = metId;
                                tempMeta.crc32 = fileMap[key].crc32;
                                tempMeta.MetaType = MetaType;
                                tempMeta.API_Name = API_Name;
                                tempMeta.File_Name = File_Name;
                                tempMeta.key = key;
                                
                                if(fileMap[key+"-meta.xml"] != undefined)
                                {
                                    tempMeta.crc32 = tempMeta.crc32+' '+fileMap[key+"-meta.xml"].crc32;
                                }
                                
                                metaCrcMap[metId] = tempMeta.crc32;
                                metaFoundMap[metId] = tempMeta;
                                meta.crc32 = tempMeta.crc32;
                                selectedCompMap[metId] = meta;
                                isFound = true;
                            }
                            else if(bundleTypes[MetaType] != undefined)
                            {
                                var tempMeta = new Object();
                                tempMeta.Id = metId;
                                tempMeta.crc32 = '';
                                tempMeta.MetaType = MetaType;
                                tempMeta.API_Name = API_Name;
                                tempMeta.File_Name = File_Name;
                                tempMeta.key = key;
                                var map32 = {};
                                
                                if (auraFileMap[File_Name] != undefined){
                                    var auraMap = auraFileMap[File_Name];
                                    for(var fName in auraMap)
                                    {
                                        map32[fName] = auraMap[fName].crc32;
                                        isFound = true;
                                    }
                                }
                                tempMeta.crc32 = composeBundleCrc(map32);
                                
                                metaCrcMap[metId] = tempMeta.crc32;
                                metaFoundMap[metId] = tempMeta;
                                meta.crc32 = tempMeta.crc32;
                                selectedCompMap[metId] = meta;
                            }
                            
                        }
                    }
                    
                    // comment this in production
                    getSizeObject1level('metaCrcMap',metaCrcMap);
                    getSizeObject2level('metaFoundMap',metaFoundMap);
                    getSizeObject2level('fileMap',fileMap);
                    getSizeObject2level('auraFileMap',metaCrcMap);
                    getSizeObject2level('allCompMap',fileMap);
                    
                    
                    $scope.compareMetaData(metaCrcMap);
                    allCompMap = {};// free memory
                    $scope.componentListPtr = []; 
            }
            
            function getSizeObject1level(name,obj){
                var keys = [];
                if (obj != undefined){
                    keys = Object.keys(obj);
                }
            }
            
            function getSizeObject2level(name,obj){
                var keys = [];
                var size = 0;
                if (obj != undefined){
                    keys = Object.keys(obj);
                }
                for (var x = 0; x < keys.length; x++){
                    var key = keys[x];
                    var o = obj[key];
                    if (o != undefined){
                        size += JSON.stringify(o).length;
                    }
                }
            }

            $scope.compareMetaData = function(metaCrcMap){
                // split all set into blocks by 4000
                var blocks = [];
                var first = 0;
                var end = BLOCKSIZE;
                var len = $scope.initialSelectionSet0.length;
                while (first < len){
                    if (end > len){
                        end = len;
                    }
                    var block = new Object();
                    block.metaIdList = $scope.initialSelectionSet0.slice(first,end);// get slice of array
                    block.crcMap = getSubMap(block.metaIdList);// get submap of map
                    blocks.push(block);
                    first = end;
                    end += BLOCKSIZE;
                }
                for (var x = 0; x < blocks.length; x++){
                }

                $scope.isLoading = true;

                $scope.compareData(blocks, function(){
                        
                        $scope.isLoading = false;
                        clearMessage();
                        hide();

                });
                
                function getSubMap(list){
                    var crcMap = {};
                    if (list != undefined && list.length > 0){
                        for (var x = 0; x < list.length; x++){
                            crcMap[list[x]] = metaCrcMap[list[x]];
                        } 
                    }
                    return crcMap;
                }   
                
            }
            
            
            /************************           Init section                ****************************/    

            // init the variables for controller
            $scope.initialize = function(){
                $scope.attIdMap = {};
                $scope.globalAttIdMap = {};
                $scope.componentBaseList = [];
                $scope.componentListPtr = [];
                $scope.typeFilter = 'all';
                $scope.searchText = '';
                var element = document.getElementById('pg:fullform:FirstPageBlock:pbs1:pbsi1:picklst1');
                if (element != undefined){
                    element.value = 'all';
                }
            
                if ($scope.isLoading == false){
                    setMessageOnPage('Loading Data...');
                    overridePageMessages();
                    $scope.isLoading = true;
                
                    dataManager.getAllItems().then(
                        function (data) {
                          if (data != null && data != undefined && data.length > 0){
                                ////console.log('got items:'+data.length);
                                // split all data in blocks
                                var blocks = [];
                                var first = 0;
                                var end = 10000;
                                while (first < data.length){
                                    if (end > data.length){
                                        end = data.length;
                                    }
                                    blocks.push(data.slice(first,end));
                                    first = end;
                                    end += 10000;
                                }
                                $scope.loadData(blocks,function(){
                                    //////console.log('load finished');
                                    $scope.isLoading = false;
                                    correctDate($scope.componentBaseList);
                                    setAll($scope.componentBaseList,false);
                                    $scope.applyFilter();
                                    clearMessage();
                                });
                                
                          }else{
                            setMessageOnPage('Nothing to commit');
                            overridePageMessages();
                          } 
                        },
                        function (error) {
                            showErrorMessage('Error:'+error);
                            $scope.isLoading = false;
                        }
                    );
                
                }
            }
            $scope.initialize();
            
            
            
            $scope.applyFilter = function(){
                if ($scope.typeFilter == 'all'){
                    var lst  = [];
                    for ( var x = 0; x < $scope.componentBaseList.length; x++){
                        lst.push($scope.componentBaseList[x]);
                    }
                    $scope.componentListPtr = lst;
                }else if ($scope.typeFilter != '' && $scope.typeFilter != undefined){
                    var lst = [];
                    for ( var x = 0; x < $scope.componentBaseList.length; x++){
                        var elem = $scope.componentBaseList[x];
                        if (elem.compType == $scope.typeFilter){
                            lst.push(elem);
                        }
                    }
                    $scope.componentListPtr = lst;
                }
                ////////console.log('size:'+lst.length);
                $scope.$apply();
            }
            
            
        });
        
        
          function clearMessage(){
            ////////console.log('clearMessage');
//          setMessageOnPage('');
            if($j('#msg') != undefined){
                 $j('#msg').remove();
            }
    }
    
        
    function unbindWindow()
    {
        $j(window).unbind();
    }
    
    function isEmpty(val){
        return val == undefined || val == null || val == '';
    }
        
        
        function getScope(){
            return angular.element(document.getElementById('angularControllerId')).scope();
        }
        
        
        // analyse and return bundle's crc32 sum (see the specs for detail)
        function composeBundleCrc(mapCrc32){
            ////console.log('componentStack '+JSON.stringify(mapCrc32));
            var crcCode = 0;
            
            // map name => crc32
            var keys = Object.keys(mapCrc32).sort();
            if (keys.length > 0 ) crcCode = mapCrc32[keys[0]];
            for (var i = 1; i < keys.length; i++){
                crcCode = Math.round((mapCrc32[keys[i]]+crcCode)/2);
            }                                   
                                                                
            return crcCode;
        }
        
        
        var Page = function(obj){
                //////////console.log('creating a page')
                this.staticLimit = 20;
                this.orderByColumn = 'compName';
                this.isReverse = false;
                this.metaOffSet = 0;
                this.totalRecords = 0;
                this.viewLimit = this.staticLimit;
                if (obj != undefined){
                    if (obj.OrderByColumn != undefined){ this.orderByColumn = obj.OrderByColumn;}
                    if (obj.isReverse != undefined){ this.isReverse = obj.isReverse;}
                    if (obj.metaOffSet != undefined){ this.metaOffSet = obj.metaOffSet;}
                    if (obj.totalRecords != undefined){ this.totalRecords = obj.totalRecords;}
                    if (obj.viewLimit != undefined){ this.viewLimit = obj.viewLimit;}
                }
        }
            
            Page.prototype.refreshOrderBy = function(orderVal) {
                this.metaOffSet = 0;
                this.viewLimit = this.metaOffSet + this.staticLimit;
                if(orderVal === this.orderByColumn)
                    this.isReverse = !this.isReverse;
                else
                {
                    this.isReverse = false;
                    this.orderByColumn = orderVal;
                }
            };
            Page.prototype.showFirst = function() {
                this.metaOffSet = 0;
                this.viewLimit = this.staticLimit;
            };
            Page.prototype.listPrevious = function() {
                this.metaOffSet = this.metaOffSet - this.staticLimit;
                if(this.metaOffSet < 0)
                    this.metaOffSet = 0;
                this.viewLimit = this.metaOffSet + this.staticLimit;
            };
            Page.prototype.listNext = function(tempTotal) {
                if((this.metaOffSet + this.staticLimit) < tempTotal)
                {
                    this.metaOffSet = this.metaOffSet + this.staticLimit;
                    this.viewLimit = this.metaOffSet + this.staticLimit;
                }
            };
            Page.prototype.showLast = function(tempTotal) {
                this.metaOffSet = tempTotal - (tempTotal % this.staticLimit);
                if(this.metaOffSet == tempTotal && this.metaOffSet != 0)
                {
                    this.metaOffSet = tempTotal - this.staticLimit;
                }
                this.viewLimit = this.metaOffSet + this.staticLimit;
            };
            Page.prototype.isPrevious = function() {
                if(this.metaOffSet < 1) 
                    return true;
                else {
                    return false;
                }
            };
            Page.prototype.isNext = function(tempTotal){
                if(tempTotal > this.metaOffSet+this.staticLimit){
                    return false;
                }
                else {
                    return true;
                }
            };
            Page.prototype.totalPageCount = function(tempTotal){
                var totalPage = parseInt(tempTotal % this.staticLimit > 0 ? (tempTotal / this.staticLimit)+1 : (tempTotal / this.staticLimit));
                return totalPage;
                
            };
            Page.prototype.currentPageNo = function(tempTotal){
                var currentPage = 1;
                var total = this.totalPageCount(tempTotal);
                ////////console.log('total='+total);
                if(this.metaOffSet <  this.staticLimit){
                    currentPage =  1;
                }else{
                    currentPage = Math.ceil(this.metaOffSet / this.staticLimit)+1;
                }
                if (currentPage > total){
                    currentPage = 1;
                    this.showFirst();
                }
                return currentPage;
            };
 
        
        
        function unpack(data, action){
            if (data != undefined && action == true){
                return pako.inflate(data,{ to: 'string' });
            }else{
                return data;
            }
        }

        function finalCommit(commitSuccess,buildId,branchIdInput) {
        
            commitIds = [];// summary list of ids of metaitems to commit
            var commitArray = getScope().getCommitSet();
            commitIds = commitIds.concat(commitArray);
            buildLogId = buildId;
            branchId = branchIdInput;
            
            ////console.log('commitSuccess');
          console.log('commitIds:'+commitIds.length + ' items');
            console.log('buildLogId'+buildLogId);
           console.log('branchId'+branchId);
            
            if (commitIds.length == 0){
                showErrorMessage('Error: select at least  1 component to commit');
                hide();
                return;
            }
        
            if(commitSuccess == true || commitSuccess == 'true')
            {
                ComponentAttachmentWraperList = [];
                bodySize = 0;
                componentMetaMap = {};
                metaIds = [];
                fileIndex = 0;
                currentIndex = 0;
                branchId = branchIdInput;
                metafound = false;
                updateProfiles();
            }
            else
            {
                hide();
            }
        }
        
        var purge;
        
        function updateProfiles(){
            
            var itemsToCommit = [];
            for (var x = 0; x < commitIds.length; x++){
                if (metaFoundMap[commitIds[x]] != undefined)
                    itemsToCommit.push(metaFoundMap[commitIds[x]]);
            }
            ////console.log('to commit: '+itemsToCommit.length);
            purge = new Validator(itemsToCommit,dataCache);
//          purge.updateProfiles(function(){
                ////console.log('purge init');
                proccesFiles();
//          });
        }
        
   var Validator = function(items,cache){
        ////console.log('call Validator');
        this.ACT_STR = 'Activity.';
        this.callback;
        this.validNames = 0;
        this.pIndex = 0;
        this.dataCache = {};
        if (cache != undefined){
            this.dataCache = cache;
        }
        this.profileList = [];
        this.errors = [];
        this.isValidationNeeded = false;//set flag always purge
        this.validName = {
            'ApexClass': [], 
            'CustomObject': [], 
            'ApexPage':[], 
            'CustomTab': [],
            'Layout': [],
            'CustomApplication':[],
            'ExternalDataSource':[],
            'CustomPermission':[],
            'CustomField':[],
            'RecordType':[],
            'FlexiPage': [],
            'DataCategoryGroup':[]
        };
        
        if (items != undefined && items.length > 0){
            for (var x = 0; x < items.length; x ++){
                var item = items[x];
                if (item.MetaType == 'Profile' || item.MetaType == 'PermissionSet'){
                    this.profileList.push(item.key);    
                }else{
                    this.addValidName(item.MetaType, item.API_Name);
                    this.isValidationNeeded == true;
                }
            }
            ////console.log('added valid names:'+this.validNames);
//          if (this.isValidationNeeded == false)
//          this.isValidationNeeded = this.profileList.length > 0;// if no profiles do nothing
        }

    }
    


Validator.prototype.addValidName = function(metaType,itemName) {
    if (this.validName[metaType] != undefined && itemName != undefined) {
        this.isValidationNeeded = true;
        this.validName[metaType].push(itemName);
        this.validNames ++;
        var itemFullName = itemName;
        //Activity custom fields to Event and Task
        if(metaType == 'CustomField' && itemFullName.indexOf(this.ACT_STR) == 0 && itemFullName.lastIndexOf('__c') == itemFullName.length - 3) {
            var tempItemName = itemFullName.substring(this.ACT_STR.length,itemFullName.length);
            this.validName[metaType].push('Task.' + tempItemName);
            this.validName[metaType].push('Event.' + tempItemName);
            this.validNames += 2;
        }
    }
}

Validator.prototype.updateProfiles = function(callback) {
    var self = this;
    if (callback != undefined){
        this.callback = callback;
        if (this.isValidationNeeded == false){
            this.callback();    
            return;
        }
    }
    if (this.profileList.length > 0){
        var key = this.profileList.shift();
        ////////console.log('process '+key);
        //////////console.log('keys '+JSON.stringify(Object.keys(this.fileMap)));
        var f = this.fileMap[key];
        if (f != undefined && f.data != undefined){
            ////////console.log('updateOneProfile');
            this.updateOneProfile(unpack(f.data,true), key,function(){
                setTimeout(function(){
                    self.updateProfiles();
                });
            });
        }else{//omit it
            ////////console.log('profile is absent');
            this.errors.push('profile is absent');
            this.updateProfiles();
        }
    }else{
        if (this.callback != undefined){
            this.callback();
        }
    }
}

Validator.prototype.updateCachedProfile = function(p, callback) {
    var self = this;
    if (callback != undefined){
        this.callback = callback;
        if (this.isValidationNeeded == false){
            this.callback();    
            return;
        }
    }
    if (p != undefined){
        this.updateOneProfile(p, '0',function(result){
                self.callback(result);
        });
    }else{
        this.callback();
    }
}

Validator.prototype.updateOneProfile = function(objectForValidation, keyToUpdate, callback) {

            ////console.log('start size '+JSON.stringify(objectForValidation).length);

            var x2js = new X2JS({useDoubleQuotes : true, stripWhitespaces : false, escapeMode: true});
            var orignal = x2js.xml_str2json(objectForValidation);
            var ObjectForVal;
            if (orignal.Profile != undefined) {
                ObjectForVal = orignal.Profile;
            }
            else if (orignal.PermissionSet != undefined) {
                ObjectForVal = orignal.PermissionSet;
            }
            if (ObjectForVal != null) {
                //APEX CLASS
                if (ObjectForVal.classAccesses != undefined) {
                    var NewArr =[];
                    var EtallonClasses = this.validName.ApexClass;
                    if(Array.isArray(ObjectForVal.classAccesses))   
                    {
                        for(var index in ObjectForVal.classAccesses) {
                            if (jQuery.inArray(ObjectForVal.classAccesses[index].apexClass, EtallonClasses) !== -1) {
                                NewArr.push(ObjectForVal.classAccesses[index]);
                            }
                        }
                    }
                    else
                    {
                        if (jQuery.inArray(ObjectForVal.classAccesses.apexClass, EtallonClasses) !== -1) {
                            NewArr.push(ObjectForVal.classAccesses);
                        }
                    }
                    if (NewArr.length > 0) {
                        ObjectForVal.classAccesses = NewArr;
                    }
                    else {
                        delete ObjectForVal.classAccesses;
                    }
                }

                //APEX PAGE
                if (ObjectForVal.pageAccesses != undefined) {
                    var NewArr =[];
                    var EtallonPages = this.validName.ApexPage;
                    if(Array.isArray(ObjectForVal.pageAccesses))    
                    {
                        for(var index in ObjectForVal.pageAccesses) {
                            if (jQuery.inArray(ObjectForVal.pageAccesses[index].apexPage, EtallonPages) !== -1) {
                                NewArr.push(ObjectForVal.pageAccesses[index]);
                            }
                        }
                    }
                    else
                    {
                        if (jQuery.inArray(ObjectForVal.pageAccesses.apexPage, EtallonPages) !== -1) {
                            NewArr.push(ObjectForVal.pageAccesses);
                        }
                    }
                    if (NewArr.length > 0) {
                        ObjectForVal.pageAccesses = NewArr;
                    }
                    else {
                        delete ObjectForVal.pageAccesses;
                    }
                }

                //TAB permision
                if (ObjectForVal.tabSettings != undefined && orignal.PermissionSet != undefined) {
                    var NewArr =[];
                    var EtallonTab = this.validName.CustomTab;
                    if(Array.isArray(ObjectForVal.tabSettings)) 
                    {
                        for(var index in ObjectForVal.tabSettings) {
                            if (jQuery.inArray(ObjectForVal.tabSettings[index].tab, EtallonTab) !== -1) {
                                NewArr.push(ObjectForVal.tabSettings[index]);
                            }
                        }
                    }
                    else
                    {
                        if (jQuery.inArray(ObjectForVal.tabSettings.tab, EtallonTab) !== -1) {
                            NewArr.push(ObjectForVal.tabSettings);
                        }
                    }
                    if (NewArr.length > 0) {
                        ObjectForVal.tabSettings = NewArr;
                    }
                    else {
                        delete ObjectForVal.tabSettings;
                    }
                }


                //TAB Profile
                if (ObjectForVal.tabVisibilities != undefined && orignal.Profile != undefined) {
                    var NewArr =[];
                    var EtallonTab = this.validName.CustomTab;
                    if(Array.isArray(ObjectForVal.tabVisibilities)) 
                    {
                        for(var index in ObjectForVal.tabVisibilities) {
                            if (jQuery.inArray(ObjectForVal.tabVisibilities[index].tab, EtallonTab) !== -1) {
                                NewArr.push(ObjectForVal.tabVisibilities[index]);
                            }
                        }
                    }
                    else
                    {
                        if (jQuery.inArray(ObjectForVal.tabVisibilities.tab, EtallonTab) !== -1) {
                            NewArr.push(ObjectForVal.tabVisibilities);
                        }
                    }
                    if (NewArr.length > 0) {
                        ObjectForVal.tabVisibilities = NewArr;
                    }
                    else {
                        delete ObjectForVal.tabVisibilities;
                    }
                }

                //profileActionOverrides Profile
                if (ObjectForVal.profileActionOverrides != undefined && orignal.Profile != undefined) {
                    var NewArr =[];
                    var EtallonTab = this.validName.FlexiPage;
                    if(Array.isArray(ObjectForVal.profileActionOverrides))  
                    {
                        for(var index in ObjectForVal.profileActionOverrides) {
                            if (jQuery.inArray(ObjectForVal.profileActionOverrides[index].content, EtallonTab) !== -1) {
                                NewArr.push(ObjectForVal.profileActionOverrides[index]);
                            }
                        }
                    }
                    else
                    {
                        if (jQuery.inArray(ObjectForVal.profileActionOverrides.content, EtallonTab) !== -1) {
                            NewArr.push(ObjectForVal.profileActionOverrides);
                        }
                    }
                    if (NewArr.length > 0) {
                        ObjectForVal.profileActionOverrides = NewArr;
                    }
                    else {
                        delete ObjectForVal.profileActionOverrides;
                    }
                }

                //categoryGroupVisibilities Profile
                if (ObjectForVal.categoryGroupVisibilities != undefined && orignal.Profile != undefined) {
                    var NewArr =[];
                    var EtallonTab = this.validName.DataCategoryGroup;
                    if(Array.isArray(ObjectForVal.categoryGroupVisibilities))   
                    {
                        for(var index in ObjectForVal.categoryGroupVisibilities) {
                            if (jQuery.inArray(ObjectForVal.categoryGroupVisibilities[index].dataCategoryGroup, EtallonTab) !== -1) {
                                NewArr.push(ObjectForVal.categoryGroupVisibilities[index]);
                            }
                        }
                    }
                    else
                    {
                        if (jQuery.inArray(ObjectForVal.categoryGroupVisibilities.dataCategoryGroup, EtallonTab) !== -1) {
                            NewArr.push(ObjectForVal.categoryGroupVisibilities);
                        }
                    }
                    if (NewArr.length > 0) {
                        ObjectForVal.categoryGroupVisibilities = NewArr;
                    }
                    else {
                        delete ObjectForVal.categoryGroupVisibilities;
                    }
                }

                //OBJECT
                if (ObjectForVal.objectPermissions != undefined) {
                    var NewArr =[];
                    var EtallonObject = this.validName.CustomObject;
                    if(Array.isArray(ObjectForVal.objectPermissions))   
                    {
                        for(var index in ObjectForVal.objectPermissions) {
                            if (jQuery.inArray(ObjectForVal.objectPermissions[index].object, EtallonObject) !== -1) {
                                NewArr.push(ObjectForVal.objectPermissions[index]);
                            }
                        }
                    }
                    else
                    {
                        if (jQuery.inArray(ObjectForVal.objectPermissions.object, EtallonObject) !== -1) {
                            NewArr.push(ObjectForVal.objectPermissions);
                        }
                    }
                    
                    if (NewArr.length > 0) {
                        ObjectForVal.objectPermissions = NewArr;
                    }
                    else {
                        delete ObjectForVal.objectPermissions;
                    }
                }

                //Layout
                if (ObjectForVal.layoutAssignments != undefined) {
                    var NewArr =[];
                    var EtallonLauout = this.validName.Layout;
                    if(Array.isArray(ObjectForVal.layoutAssignments))   
                    {
                        for(var index in ObjectForVal.layoutAssignments) {
                            if (jQuery.inArray(ObjectForVal.layoutAssignments[index].layout, EtallonLauout) !== -1) {
                                if(ObjectForVal.layoutAssignments[index].recordType != undefined) {
                                    var RecordTypesAvailLi = this.validName.RecordType;
                                    if (jQuery.inArray(ObjectForVal.layoutAssignments[index].recordType, RecordTypesAvailLi) !== -1) {
                                        NewArr.push(ObjectForVal.layoutAssignments[index]);
                                    }
                                }
                                else {
                                    NewArr.push(ObjectForVal.layoutAssignments[index]);
                                }
                            }
                        }
                    }
                    else
                    {
                        if (jQuery.inArray(ObjectForVal.layoutAssignments.layout, EtallonLauout) !== -1) {
                                //NewArr.push(ObjectForVal.layoutAssignments);
                            if(ObjectForVal.layoutAssignments.recordType != undefined) {
                                var RecordTypesAvailLi = this.validName.RecordType;
                                if (jQuery.inArray(ObjectForVal.layoutAssignments.recordType, RecordTypesAvailLi) !== -1) {
                                    NewArr.push(ObjectForVal.layoutAssignments);
                                }
                            }
                            else {
                                NewArr.push(ObjectForVal.layoutAssignments);
                            }
                        }
                    }
                    
                    if (NewArr.length > 0) {
                        ObjectForVal.layoutAssignments = NewArr;
                    }
                    else {
                        delete ObjectForVal.layoutAssignments;
                    }
                }

                //recordType
                if (ObjectForVal.recordTypeVisibilities != undefined) {
                    var NewArr =[];
                    var EtallonObject = this.validName.RecordType;
                    if (EtallonObject.length > 0) {
                        if(Array.isArray(ObjectForVal.recordTypeVisibilities))  
                        {
                            for(var index =0; index < ObjectForVal.recordTypeVisibilities.length; index++) {
                                var RecordTypeName = ObjectForVal.recordTypeVisibilities[index].recordType; 
                                if (jQuery.inArray(RecordTypeName, EtallonObject) !== -1) {
                                    NewArr.push(ObjectForVal.recordTypeVisibilities[index]);
                                }
                            }
                        }
                        else
                        {
                            var RecordTypeName = ObjectForVal.recordTypeVisibilities.recordType;
                            if (jQuery.inArray(RecordTypeName, EtallonObject) !== -1) {
                                NewArr.push(ObjectForVal.recordTypeVisibilities);
                            }
                        }
                    }
                    if (NewArr.length > 0) {
                        ObjectForVal.recordTypeVisibilities = NewArr;
                    }
                    else {
                        delete ObjectForVal.recordTypeVisibilities;
                    }
                }

                //fieldPermissions
                if (ObjectForVal.fieldPermissions != undefined) {
                    var NewArr =[];
                    var EtallonObject = this.validName.CustomField;
                    if (EtallonObject.length > 0) {
                        if(Array.isArray(ObjectForVal.fieldPermissions))    
                        {
                            for(var index =0; index < ObjectForVal.fieldPermissions.length; index++) {
                                var fieldName = ObjectForVal.fieldPermissions[index].field;
                                if (jQuery.inArray(fieldName, EtallonObject) !== -1) {
                                    NewArr.push(ObjectForVal.fieldPermissions[index]);
                                }
                            }
                        }
                        else
                        {
                            var fieldName = ObjectForVal.fieldPermissions.field;
                            if (jQuery.inArray(fieldName, EtallonObject) !== -1) {
                                NewArr.push(ObjectForVal.fieldPermissions);
                            }
                        }
                    }
                    if (NewArr.length > 0) {
                        ObjectForVal.fieldPermissions = NewArr;
                    }
                    else {
                        delete ObjectForVal.fieldPermissions;
                    }
                }
                
                //applicationVisibilities
                if (ObjectForVal.applicationVisibilities != undefined) {
                    var NewArr =[];
                    var EtallonPages = this.validName.CustomApplication;
                    if(Array.isArray(ObjectForVal.applicationVisibilities)) 
                    {
                        for(var index in ObjectForVal.applicationVisibilities) {
                            if (jQuery.inArray(ObjectForVal.applicationVisibilities[index].application, EtallonPages) !== -1) {
                                NewArr.push(ObjectForVal.applicationVisibilities[index]);
                            }
                        }
                    }
                    else
                    {
                        if (jQuery.inArray(ObjectForVal.applicationVisibilities.application, EtallonPages) !== -1) {
                            NewArr.push(ObjectForVal.applicationVisibilities);
                        }
                    }
                    
                    if (NewArr.length > 0) {
                        ObjectForVal.applicationVisibilities = NewArr;
                    }
                    else {
                        delete ObjectForVal.applicationVisibilities;
                    }
                }
                
                //externalDataSourceAccesses
                if (ObjectForVal.externalDataSourceAccesses != undefined) {
                    var NewArr =[];
                    var EtallonPages = this.validName.ExternalDataSource;
                    if(Array.isArray(ObjectForVal.externalDataSourceAccesses))  {
                        for(var index in ObjectForVal.externalDataSourceAccesses) {
                            if (jQuery.inArray(ObjectForVal.externalDataSourceAccesses[index].externalDataSource, EtallonPages) !== -1) {
                                NewArr.push(ObjectForVal.externalDataSourceAccesses[index]);
                            }
                        }
                    }
                    else {
                        if (jQuery.inArray(ObjectForVal.externalDataSourceAccesses.externalDataSource, EtallonPages) !== -1) {
                            NewArr.push(ObjectForVal.externalDataSourceAccesses);
                        }
                    }
                    if (NewArr.length > 0) {
                        ObjectForVal.externalDataSourceAccesses = NewArr;
                    }
                    else {
                        delete ObjectForVal.externalDataSourceAccesses;
                    }
                }
                
                //customPermissions
                if (ObjectForVal.customPermissions != undefined) {
                    var NewArr =[];
                    var EtallonPages = this.validName.CustomPermission;
                    if(Array.isArray(ObjectForVal.customPermissions))   
                    {
                        for(var index in ObjectForVal.customPermissions) {
                            if (jQuery.inArray(ObjectForVal.customPermissions[index].name, EtallonPages) !== -1) {
                                NewArr.push(ObjectForVal.customPermissions[index]);
                            }
                        }
                    }
                    else
                    {
                        if (jQuery.inArray(ObjectForVal.customPermissions.name, EtallonPages) !== -1) {
                            NewArr.push(ObjectForVal.customPermissions);
                        }
                    }
                    if (NewArr.length > 0) {
                        ObjectForVal.customPermissions = NewArr;
                    }
                    else {
                        delete ObjectForVal.customPermissions;
                    }
                }
            }
            if(ObjectForVal != null && ObjectForVal.userPermissions != undefined)
                delete ObjectForVal.userPermissions;
            if(ObjectForVal != null && ObjectForVal.loginIpRanges != undefined)
                delete ObjectForVal.loginIpRanges;
            if (orignal.Profile != undefined && ObjectForVal != null) {
                 orignal.Profile = ObjectForVal;
            }
            else if (orignal.PermissionSet != undefined && ObjectForVal != null) {
                orignal.PermissionSet = ObjectForVal;
            }
            
            var returnXML = x2js.json2xml_str(orignal);
            ////console.log('size after purge:'+ ((returnXML == undefined)? 0 : returnXML.length));
            ////console.log('after purge:'+returnXML);
            if (keyToUpdate != '0'){
                this.fileMap[keyToUpdate].data = pako.deflate(returnXML, { to: 'string' });
                callback();
            }else{
                callback(returnXML);
            }
        }

        // used to repack all data into componentMetaMap
        function proccesFiles()
        {
            //return;
            console.log('process files');
            ////console.log('fileIndex '+fileIndex);
            var profile;
            if(metaFoundMap[commitIds[fileIndex]] != undefined)
            {
                var isDeployNeeded = false;
                var item = metaFoundMap[commitIds[fileIndex]];
                //console.log('process item'+JSON.stringify(item));
                var fileZip = new JSZip();
                if(bundleTypes[item.MetaType] != undefined)
                {
                    var auraMap = auraFileMap[item.File_Name];
                    //////console.log('process auar '+JSON.stringify(auraMap));
                    if (auraMap != undefined){
                        for(var fName in auraMap)
                        {
                            fileZip.file(fName,unpack(auraMap[fName].data),{binary:true});
                        }
                    }
                    auraFileMap[item.File_Name] = null;
                }
                else
                {
                    //console.log('Yo yo item');
                    //console.log(item);
                    if(fileMap[item.key+"-meta.xml"] != undefined)
                    {
                        fileZip.file(item.File_Name+"-meta.xml",unpack(fileMap[item.key+"-meta.xml"].data),{binary:true});
                        fileMap[item.key+"-meta.xml"] = {};
                    }
                    if (item.MetaType == 'Profile' || item.MetaType == 'PermissionSet'){
                        profile = fileMap[item.key].data;
                        fileZip.file(item.File_Name,unpack(profile,true),{binary:true});
                    }else if (mmap[item.MetaType] == undefined){
                        fileZip.file(item.File_Name,unpack(fileMap[item.key].data),{binary:true});
                    }else{//inner components
                        fileZip.file(item.File_Name,unpack(fileMap[item.key].data),{binary:false});
                    }
                    fileMap[item.key] = {};
                }
                item.data = fileZip.generate({type:"base64",compression:"DEFLATE"});
                fileZip = new JSZip();
                if(item.data.length + bodySize > ZIPPACK_LIMIT || currentIndex > 500)
                {
                    if(isMapNonEmpty(componentMetaMap))
                    {
                        var commitObj = new Object();
                        commitObj.dataMap = componentMetaMap;
                        commitObj.metaIds = metaIds;
                        ComponentAttachmentWraperList.push(commitObj);
                        bodySize = 0;
                        componentMetaMap = {};
                        metaIds = [];
                        isDeployNeeded = true;
                        currentIndex = 0;
                    }
                }
                bodySize  = bodySize + item.data.length;
                var newObj = new Object();
                newObj.data=item.data;
                newObj.crc32=item.crc32;
                newObj.filename=item.File_Name;
                componentMetaMap[item.MetaType+'#'+item.API_Name] = newObj;
                metaIds.push(commitIds[fileIndex]);
                metaFoundMap[commitIds[fileIndex]] = {};
                currentIndex ++;
                //console.log('process newObj'+JSON.stringify(newObj));
            }
            else
            {
                //////console.log('Item not found in zip.');
            }
            
            fileIndex ++;
            if (commitIds.length > fileIndex && isDeployNeeded == false) {
                setTimeout(function(){
                    proccesFiles();
                });
            }else{
                finishCommit();
            }
        }
        
        function finishCommit() 
        {
            ////console.log('finishCommit:commitIds'+commitIds.length);
            if(commitIds.length <= fileIndex && isMapNonEmpty(componentMetaMap))
            {
                var commitObj = new Object();
                commitObj.dataMap = componentMetaMap;
                commitObj.metaIds = metaIds;
                ComponentAttachmentWraperList.push(commitObj);
                componentMetaMap = {};
            }
            ////console.log('ComponentAttachmentWraperList:'+ComponentAttachmentWraperList.length);
            if(ComponentAttachmentWraperList.length > 0)
            {
                commitInChunks();
            }
            else
            {
                showMessage('No metadata items found.');
            }
        }

        function commitInChunks()
        {
            console.log('commitInChunks ');
            var msgStr =  'Committed '+ fileIndex + '/' + commitIds.length + ' components';
            setMessageOnPage(msgStr);// TODO: verify is fileIndex set right
            overridePageMessages();
            setText(msgStr);
            
            //console.log('ComponentAttachmentWraperList:size '+ComponentAttachmentWraperList.length);
            if (ComponentAttachmentWraperList.length > 0){
                var commitObj = ComponentAttachmentWraperList[0];
                ////console.log('commitObj:' + JSON.stringify(commitObj).length + 'bytes');
                commitByApex(JSON.stringify(commitObj));
            }else{
                if (commitIds.length > fileIndex){
                    setTimeout(function(){
                        proccesFiles();
                    });
                }else{
                    buildZips();
                }
            }
            overridePageMessages();
        }
        
        var patchIdList = [];
        var currentPatch;
        var currentPatchBkup;
        var CIOn = false;
        var logIdList = [];
        var currentLog;
        
        function populatePatch(patchIdLi, logIdLi, logId, validateOnly){
            console.log('patchIdLi, '+patchIdLi);
            console.log('logIdLi, '+logIdLi);// id of tracking metadata log for each org
            console.log('logId, '+logId);// transaction id
            CIOn = false;// if  false (some deploy params invalid) then do not create deploy zip 
            if (patchIdLi != undefined && patchIdLi != '' && logIdLi != undefined && logIdLi != '' && logId != undefined && logId != ''){
                patchIdList = JSON.parse(patchIdLi);
                logIdList = JSON.parse(logIdLi);
                CIOn = true;
            }
            
            if (CIOn == false){//no patches were created
                // go next chunk
                if (ComponentAttachmentWraperList.length > 0){
                    ComponentAttachmentWraperList.shift();
                }
                commitInChunks();
            }else{
                if (patchIdList.length > 0){
                        currentPatch = patchIdList.shift();
                        console.log('insert, '+currentPatch);
                        insertPatchManifest(currentPatch);
                }else{// all patches populated, exec next step
                    updateDeployZipCache();
                }
            }
        }

        var SF_COLLECT_BKUP_INFO = '{!$RemoteAction.OrgComponentToBranchCommitController.collectBackupInfo}';

        function insertPatchBkup(validateOnly){
            ////console.log('insertPatchBkup, validateOnly='+validateOnly);
            if (logIdList.length > 0){
                currentLog = logIdList.shift();
                if (validateOnly == true || validateOnly == 'true'){// do not create rollback if validation only set
                    updateDeployZipCache();
                }else{// executed only on validateOnly = false
                    Visualforce.remoting.Manager.invokeAction(
                            '{!$RemoteAction.OrgComponentToBranchCommitController.setUpAuthentication}',
                            currentLog,
                            handleAuthInformation
                        );
                }
            }else{
                updateDeployZipCache();
            }
        }
        
        
        function handleAuthInformation(r,e)
        {
            if(e.status && r){
                if (r.msg == ''){
                    var rollBack = new RollBackZip(r, currentLog, sessionId, SF_COLLECT_BKUP_INFO, currentPatchBkup);
                    rollBack.createRollBackZip(currentPatch, function(err){
                        // TODO: analyse error list and cancel some patches if needed
                        currentPatchBkup = rollBack.getBkup();
                        insertPatchBkup(false);// with false flag because  handleAuthInformation exec only in this condition
                    });
                }else{
                    showMessage(r.msg);
                }
            }else{
                showMessage(e.message);
            }
        }
        
        // put in global cache all necessary data
        // base64, filename,compName,compType
        var dataCache = {};// cache rep
        var dataList = [];// cache keys as list
        var dataCacheIndex = 0;// the lastest key to add
        var totalCacheSize = 0;
        
        function updateDeployZipCache(){
            ////console.log('calling composeDeployZip');
            ////console.log('buildLogId='+buildLogId);
            //////console.log('ComponentAttachmentWraperList '+ComponentAttachmentWraperList.length);
            
            if (ComponentAttachmentWraperList.length > 0){
            
                // update cache only if all vars are valid
                if (buildLogId != null && buildLogId != undefined){
                    var commitObj = ComponentAttachmentWraperList.shift();//drop old map
                    for(var key in commitObj.dataMap){
                        if (totalCacheSize > ZIPPACK_LIMIT) break;
                        dataCache[key] = commitObj.dataMap[key].data;// add all b64 to cache
                        dataList.push(key);
                        if (dataCache[key] != undefined){
                            totalCacheSize += dataCache[key].length;
                        }
                    }
                }
            }
            commitInChunks();// close the cycle
        }
        
        // compose and insert deployzip
        // first - static resources (if exist)
        // split by blocks in 2.5MB
        function buildZips(){
            console.log('from ' + dataList.length + 'items');
            dataCacheIndex = 0;
            var isSplitted = totalCacheSize > ZIPPACK_LIMIT;
            if (dataList.length > 0 && isSplitted == false){
                buildBlocks();
            }else{
                sync(isSplitted);
            }
        }
        
        function buildBlocks(){
            var zipMap = {};
            var mapSize = 0;
            var counter = 0;
            var keyList = [];
            var dataMap = {};
            var compMap = {};
            var deployFilenamesMap = {};
            
            
            var composeBlock = function(){
                if (dataCacheIndex < dataList.length){
                    var key = dataList[dataCacheIndex];
                    var base64 = dataCache[key];
                    //console.log('compose block:'+key);
                    
                    if ((mapSize + base64.length) < ZIPPACK_LIMIT && counter < 9000){
                        mapSize += base64.length;
                        dataCacheIndex ++;// inc after get 1 zip
                        var zip = new JSZip(base64, {base64:true});
                        delete dataCache[key];
                        zipMap[key] = zip;
                        var componentType = key.substr(0,key.indexOf('#'));
                    
                        for(var fileName in zip.files){
                            if(fileName != undefined && fileName.charAt(fileName.length - 1) != '/' && fileName != 'package.xml' && fileName != 'undefined'){
                                if(mmap[componentType] == undefined){
                                    if (compMap[key] == undefined){
                                        compMap[key] = [];
                                    }
                                    compMap[key].push(fileName);
                                    if (deployFilenamesMap[fileName] == undefined){
                                        deployFilenamesMap[fileName] = true;
                                        counter ++;
                                    }
                                }else{// this branch executed once (always)
                                    if (compMap[key] == undefined){
                                        compMap[key] = [];
                                    }
                                    compMap[key].push(fileName);
                                    counter ++;
                                }
                            }
                        }
                        keyList.push(key);
                        setTimeout(function(){
                            composeBlock();
                        });
                    }else{
                        composeDeployZip(keyList, compMap, zipMap);
                        deployFilenamesMap = {};
                    }
                }else{// all done
                    composeDeployZip(keyList,  compMap, zipMap);
                    deployFilenamesMap = {};
                }
            }
            // end of definition
            //////console.log('dataCacheIndex='+dataCacheIndex);
            if (dataCacheIndex < dataList.length){
                composeBlock();
            }else{
                sync(false);
            }
            
        }

        function sync(isSplitted){
            //////console.log('Commit done successfully ');
            //return;
            var comment = '';
            if (isSplitted == true){
                comment = 'The size of the attachment more than 3 MB: deploy the patch manually';
                window.alert(comment);
            }
            console.log('comment:'+comment); 
            synchronize(comment);
            showMessage('Commit done successfully.#confirm');
        }       
        
        function composeDeployZip(keyList,  compMap, zipMap){
            //console.log('calling composeDeployZip');
            //////console.log('keyList '+JSON.stringify(keyList));
            
            if (keyList.length > 0){
                
                // form package
                var mainZip = {};
                var blobs = {};
                var packageXmlMap = {};
                

            var composePackage = function(list){
                if (list.length == 0){// generate zip
                   var xmlData = packageXmlCreator(packageXmlMap);
                   mainZip[xmlName] = xmlData;
                   // generate a list of files to compress
                   var files = Object.keys(mainZip);

                   packageZipFileCreator(blobs,files,mainZip);
                }else{
                    var key = list.shift();
                    var fileNames = compMap[key];
                    //console.log('key='+key);
                    //console.log('fileNames='+JSON.stringify(fileNames));
                    var compType = key.substr(0,key.indexOf('#'));
                    var compName = key.substr(key.indexOf('#')+1);
                            
                    var packageXmlLi = [];
                    if(packageXmlMap[compType] != undefined){
                         packageXmlLi = packageXmlMap[compType];
                    }
                    packageXmlLi.push(compName);
                    packageXmlMap[compType] = packageXmlLi;
                    
                    if (compType == 'Profile' || compType == 'PermissionSet'){
                        var zip = zipMap[key];
                        if (zip != undefined){
                            var fileName = fileNames[0];
                            var latestXML = zip.files[fileName].asBinary();
                        
                            purge.updateCachedProfile(latestXML, function(endXml){
                                if (endXml != undefined){
                                    blobs[fileName] = true;// interpret as blobs
                                    mainZip[fileName] = endXml;
                                }
                                setTimeout(function(){
                                    composePackage(list);
                                });                                 
                            });
                        }
                        return;
                    }

                    if(mmap[compType]!= undefined){
                        var fileName = fileNames[0];
                        blobs[fileNames[0]] = true;// interpret as blobs
                        if(mainZip[fileName] != undefined){// case of inner components - 2nd and more times
                            var oldXML = mainZip[fileName];
                            var zip = zipMap[key];
                            if (zip != undefined){
                                var latestXML = zip.files[fileName].asBinary();
                                var tempName = ""+compName;
                                if(tempName.lastIndexOf('.') > -1){
                                    tempName = tempName.slice(tempName.lastIndexOf('.')+1,tempName.length)
                                }
                                var customXML = getChildPartXml(latestXML, fileName, tempName, oldXML, compType);//TODO - can be optimized
                                mainZip[fileName] = customXML;
                                //console.log('oldXML='+oldXML);
                                //console.log('customXML='+customXML);
                                //console.log('latestXML='+latestXML);
                            }
                        }else{
                            var zip = zipMap[key];
                            if (zip != undefined){
                                mainZip[fileName] = zip.files[fileName].asBinary();
                            }
                        }
                    }else if(bundleTypes[compType] != undefined){
                           var zip = zipMap[key];
                           if (zip != undefined){
                            for (var f = 0; f < fileNames.length; f++){
                                blobs[fileNames[f]] = true;
                                mainZip[fileNames[f]] = zip.files[fileNames[f]].asBinary();
                            }
                           }
                    }else{
                           var zip = zipMap[key];
                           if (zip != undefined){
                             for(var x = 0; x < fileNames.length; x++){
                                blobs[fileNames[x]] = true;// interpret as blobs
                                mainZip[fileNames[x]] = zip.files[fileNames[x]].asBinary();
                             }
                           }
                    }
                     
                    setTimeout(function(){
                        composePackage(list);
                    });
                }
              }//end of definition for composePackage
              //////console.log('compose package from '+keyList.length +'items');
              composePackage(keyList);
            }else{
                //////console.log('warning:trying to build empty packages (keyList is empty)');
                buildBlock();
            }
        }
        
        function isText(type){
            return (type == 'Profile' || type == 'PermissionSet' || mmap[type] != undefined || parentMap[type] != undefined);
        }
        
        function packageZipFileCreator(blobs,files,mainZip) {
            var addIndex = 0;
            var tempWriter;
            
            function nextFile() 
            {
                var name = files[addIndex];
                var data = mainZip[name];
                var objToRead;
                if (blobs[name] == undefined){
                    objToRead =  new zip.TextReader(data);
                }else{
                    objToRead = new zip.BlobReader(new Blob([str2bytes(data)]));
                }   
                    tempWriter.add(name, objToRead, function() {
                        addIndex++;
                        delete mainZip[name];
                        if(addIndex < files.length){
                            nextFile();
                        }else{
                            tempWriter.close(function(base64Data) {
                                base64Data = base64Data.slice(base64Data.indexOf(';base64,') + 8);
                                ////console.log('insertAtt,'+ base64Data.length + 'bytes');
                                //////console.log('currentPatch:'+ currentPatch);
                                
                                insertAtt(base64Data,currentPatch);
                                // go next
                            });
                        }
                    });
            }
            
            function str2bytes (str) {
                if (str == undefined) return new Uint8Array();  
                var bytes = new Uint8Array(str.length);
                for (var i=0; i<str.length; i++) {
                    bytes[i] = str.charCodeAt(i);
                }
                return bytes;
            }
            

            function createZipWriter() {
                  zip.createWriter(new zip.Data64URIWriter(), function(writer2) {
                    tempWriter = writer2;
                    nextFile();
                }, function(error) {
                    // onerror callback
                    ////////////console.log('Error while creating single zip.');
                    ////////////console.log(error);
                    ////////////console.log(JSON.stringify(error));
                    if(error.message != undefined)
                    {
                        showMessage(error.message);
                    }
                    else
                    {
                        showMessage('Unknown error.');
                    }
                });
            }
            createZipWriter();
        }
        
        function packageXmlCreator(packageXmlMap)
        {
            var xml = '<?xml version="1.0" encoding="UTF-8"?><Package xmlns="http://soap.sforce.com/2006/04/metadata">';
            for(var mType in packageXmlMap)
            {
                var packageXmlLi = [];
                packageXmlLi = packageXmlMap[mType];
                xml = xml + '<types>';
                for(var index in packageXmlLi)
                {
                    if(index < packageXmlLi.length)
                    {
                        xml = xml + '<members>';
                        xml = xml + packageXmlLi[index];
                        xml = xml + '</members>';
                    }
                }
                xml = xml + '<name>'+mType+'</name></types>';
            }
            xml = xml + '<version>'+apiVersion+'</version></Package>';
            return xml;
        }
        
    function getChildPartXml(newXml,fileName,itemName,oldXml,metaType)
    {
        var x2js = new X2JS({useDoubleQuotes : true, stripWhitespaces : false, escapeMode: true});
        var tgtmap = {};
        var srcjson = x2js.xml_str2json(newXml);
        if(srcjson != null)
        {
            var srcitems;
            if(metaType == 'CustomLabel')
            {
                var srcMetaItem = srcjson.CustomLabels;
                srcitems = srcMetaItem.labels;
            }
            else if(metaType == 'CustomField')
            {
                var srcMetaItem = srcjson.CustomObject;
                srcitems = srcMetaItem.fields;
            }
            else if(metaType == 'ListView')
            {
                var srcMetaItem = srcjson.CustomObject;
                srcitems = srcMetaItem.listViews;
            }
            else if(metaType == 'CompactLayout')
            {
                var srcMetaItem = srcjson.CustomObject;
                srcitems = srcMetaItem.compactLayouts;
            }
            else if(metaType == 'WebLink')
            {
                var srcMetaItem = srcjson.CustomObject;
                srcitems = srcMetaItem.webLinks;
            }
            else if(metaType == 'RecordType')
            {
                var srcMetaItem = srcjson.CustomObject;
                srcitems = srcMetaItem.recordTypes;
            }
            else if(metaType == 'FieldSet')
            {
                var srcMetaItem = srcjson.CustomObject;
                srcitems = srcMetaItem.fieldSets;
            }
            else if(metaType == 'ValidationRule')
            {
                var srcMetaItem = srcjson.CustomObject;
                srcitems = srcMetaItem.validationRules;
            }
            else if(metaType == 'AssignmentRule')
            {
                var srcMetaItem = srcjson.AssignmentRules;
                srcitems = srcMetaItem.assignmentRule;
            }
            else if(metaType == 'AutoResponseRule')
            {
                var srcMetaItem = srcjson.AutoResponseRules;
                srcitems = srcMetaItem.autoResponseRule;
            }
            else if(metaType == 'WorkflowTask')
            {
                var srcMetaItem = srcjson.Workflow;
                srcitems = srcMetaItem.tasks;
            }
            else if(metaType == 'WorkflowOutboundMessage')
            {
                var srcMetaItem = srcjson.Workflow;
                srcitems = srcMetaItem.outboundMessages;
            }
            else if(metaType == 'WorkflowFieldUpdate')
            {
                var srcMetaItem = srcjson.Workflow;
                srcitems = srcMetaItem.fieldUpdates;
            }
            else if(metaType == 'WorkflowKnowledgePublish')
            {
                var srcMetaItem = srcjson.Workflow;
                srcitems = srcMetaItem.knowledgePublishes;
            }
            else if(metaType == 'WorkflowAlert')
            {
                var srcMetaItem = srcjson.Workflow;
                srcitems = srcMetaItem.alerts;
            }
            else if( metaType == 'WorkflowRule')
            {
                var srcMetaItem = srcjson.Workflow;
                srcitems = srcMetaItem.rules;
            }
            ////
            else if(metaType == 'SharingCriteriaRule')
            {
                var srcMetaItem = srcjson.SharingRules;
                srcitems = srcMetaItem.sharingCriteriaRules;
            }
            else if(metaType == 'SharingOwnerRule')
            {
                var srcMetaItem = srcjson.SharingRules;
                srcitems = srcMetaItem.sharingOwnerRules;
            }
            else if(metaType == 'BusinessProcess')
            {
                var srcMetaItem = srcjson.CustomObject;
                srcitems = srcMetaItem.businessProcesses;
            }
            else if(metaType == 'SharingReason')
            {
                var srcMetaItem = srcjson.CustomObject;
                srcitems = srcMetaItem.sharingReasons;
            }
            else if(metaType == 'EscalationRule')
            {
                var srcMetaItem = srcjson.EscalationRules;
                srcitems = srcMetaItem.escalationRule;
            }
            else if(metaType == 'MatchingRule')    
            {
                var srcMetaItem = srcjson.MatchingRules;
                srcitems = srcMetaItem.matchingRules;
            }
            else if(metaType == 'ManagedTopic')
            {
                var srcMetaItem = srcjson.ManagedTopics;
                srcitems = srcMetaItem.ManagedTopic;
            }
            ////
            if(srcitems != undefined)
            {
                if(srcitems.fullName == undefined)
                {                   
                    $.each(srcitems, function( i, v )
                    {
                        tgtmap[v.fullName] = JSON.stringify(v);
                    });  
                }
                else
                {
                    tgtmap[srcitems.fullName] = JSON.stringify(srcitems);
                }
            }
        }

        if(tgtmap[itemName] != undefined)
        {
            tempJsn = x2js.xml_str2json(oldXml);
            if(tempJsn != null)
            {
                var obje;
                var templi;
                var preMap = {};
                if(metaType == 'CustomLabel')
                {
                    obje = tempJsn.CustomLabels;
                    templi = obje.labels;
                }
                else if(metaType == 'CustomField')
                {
                    obje = tempJsn.CustomObject;
                    templi = obje.fields;
                }
                else if(metaType == 'ListView')
                {
                    obje = tempJsn.CustomObject;
                    templi = obje.listViews;
                }
                else if(metaType == 'CompactLayout')
                {
                    obje = tempJsn.CustomObject;
                    templi = obje.compactLayouts;
                }
                else if(metaType == 'WebLink')
                {
                    obje = tempJsn.CustomObject;
                    templi = obje.webLinks;
                }
                else if(metaType == 'RecordType')
                {
                    obje = tempJsn.CustomObject;
                    templi = obje.recordTypes;
                }
                else if(metaType == 'FieldSet')
                {
                    obje = tempJsn.CustomObject;
                    templi = obje.fieldSets;
                }
                else if(metaType == 'ValidationRule')
                {
                    obje = tempJsn.CustomObject;
                    templi = obje.validationRules;
                }
                else if(metaType == 'AssignmentRule')
                {
                    obje = tempJsn.AssignmentRules;
                    templi = obje.assignmentRule;
                }
                else if(metaType == 'AutoResponseRule')
                {
                    obje = tempJsn.AutoResponseRules;
                    templi = obje.autoResponseRule;
                }
                else if(metaType == 'WorkflowTask')
                {
                    obje = tempJsn.Workflow;
                    templi = obje.tasks;
                }
                else if(metaType == 'WorkflowOutboundMessage')
                {
                    obje = tempJsn.Workflow;
                    templi = obje.outboundMessages;
                }
                else if(metaType == 'WorkflowFieldUpdate')
                {
                    obje = tempJsn.Workflow;
                    templi = obje.fieldUpdates;
                }
                else if(metaType == 'WorkflowKnowledgePublish')
                {
                    obje = tempJsn.Workflow;
                    templi = obje.knowledgePublishes;
                }
                else if(metaType == 'WorkflowAlert')
                {
                    obje = tempJsn.Workflow;
                    templi = obje.alerts;
                }
                else if(metaType == 'WorkflowRule')
                {
                    obje = tempJsn.Workflow;
                    templi = obje.rules;
                }
                ////
                else if(metaType == 'SharingCriteriaRule')
                {
                    obje = tempJsn.SharingRules;
                    templi = obje.sharingCriteriaRules;
                }
                else if(metaType == 'SharingOwnerRule')
                {
                    obje = tempJsn.SharingRules;
                    templi = obje.sharingOwnerRules;
                }
                else if(metaType == 'BusinessProcess')
                {
                    obje = tempJsn.CustomObject;
                    templi = obje.businessProcesses;
                }
                else if(metaType == 'SharingReason')
                {
                    obje = tempJsn.CustomObject;
                    templi = obje.sharingReasons;
                }
                else if(metaType == 'EscalationRule')
                {
                    obje = tempJsn.EscalationRules;
                    templi = obje.escalationRule;
                }
                else if(metaType == 'MatchingRule')    
                {
                    obje = tempJsn.MatchingRules;
                    templi = obje.matchingRules;
                }
                else if(metaType == 'ManagedTopic')
                {
                    obje = tempJsn.ManagedTopics;
                    templi = obje.ManagedTopic;
                }
                
                ////
                
                if(templi != undefined)
                {
                    if(templi.fullName == undefined)
                    {                   
                        $.each(templi, function( i, v )
                        {
                            preMap[v.fullName] = JSON.stringify(v);
                        });  
                    }
                    else
                    {
                        preMap[templi.fullName] = JSON.stringify(templi);
                    }
                }
                preMap[itemName] = tgtmap[itemName];
                updatedJsn = '[';
                for(var name in preMap)
                {
                    if(updatedJsn == '[')
                    {
                        updatedJsn += preMap[name];
                    }
                    else
                    {
                        updatedJsn+=','+preMap[name];
                    }
                }
                updatedJsn+=']';
                if(metaType == 'CustomLabel')
                {
                    obje.labels = JSON.parse(updatedJsn);
                    tempJsn.CustomLabels = obje;
                }
                else if(metaType == 'CustomField')
                {
                    obje.fields = JSON.parse(updatedJsn);
                    tempJsn.CustomObject = obje;
                }
                else if(metaType == 'ListView')
                {
                    obje.listViews = JSON.parse(updatedJsn);
                    tempJsn.CustomObject = obje;
                }
                else if(metaType == 'CompactLayout')
                {
                    obje.compactLayouts = JSON.parse(updatedJsn);
                    tempJsn.CustomObject = obje;
                }
                else if(metaType == 'WebLink')
                {
                    obje.webLinks = JSON.parse(updatedJsn);
                    tempJsn.CustomObject = obje;
                }
                else if(metaType == 'RecordType')
                {
                    obje.recordTypes = JSON.parse(updatedJsn);
                    tempJsn.CustomObject = obje;
                }
                else if(metaType == 'FieldSet')
                {
                    obje.fieldSets = JSON.parse(updatedJsn);
                    tempJsn.CustomObject = obje;
                }
                else if(metaType == 'ValidationRule')
                {   
                    obje.validationRules = JSON.parse(updatedJsn);
                    tempJsn.CustomObject = obje;
                }
                else if(metaType == 'AssignmentRule')
                {       
                    obje.assignmentRule = JSON.parse(updatedJsn);
                    tempJsn.AssignmentRules = obje;
                }
                else if(metaType == 'AutoResponseRule')
                {
                    obje.autoResponseRule = JSON.parse(updatedJsn);
                    tempJsn.AutoResponseRules = obje;
                }
                else if(metaType == 'WorkflowTask')
                {
                    obje.tasks = JSON.parse(updatedJsn);
                    tempJsn.Workflow = obje;
                }
                else if(metaType == 'WorkflowOutboundMessage')
                {
                    obje.outboundMessages = JSON.parse(updatedJsn);
                    tempJsn.Workflow = obje;
                }
                else if(metaType == 'WorkflowFieldUpdate')
                {
                    obje.fieldUpdates = JSON.parse(updatedJsn);
                    tempJsn.Workflow = obje;
                }
                else if(metaType == 'WorkflowKnowledgePublish')
                {
                    obje.knowledgePublishes = JSON.parse(updatedJsn);
                    tempJsn.Workflow = obje;
                }
                else if(metaType == 'WorkflowAlert')
                {
                    obje.alerts = JSON.parse(updatedJsn);
                    tempJsn.Workflow = obje;
                }
                else if(metaType == 'WorkflowRule')
                {
                    obje.rules = JSON.parse(updatedJsn);
                    tempJsn.Workflow = obje;
                }
                ////
                else if(metaType == 'SharingCriteriaRule')
                {
                    obje.sharingCriteriaRules = JSON.parse(updatedJsn);
                    tempJsn.SharingRules = obje;
                }
                else if(metaType == 'SharingOwnerRule')
                {
                    obje.sharingOwnerRules = JSON.parse(updatedJsn);
                    tempJsn.SharingRules = obje;
                }
                else if(metaType == 'BusinessProcess')
                {
                    obje.businessProcesses = JSON.parse(updatedJsn);
                    tempJsn.CustomObject = obje;
                }
                else if(metaType == 'SharingReason')
                {
                    obje.sharingReasons = JSON.parse(updatedJsn);
                    tempJsn.CustomObject = obje;
                }
                else if(metaType == 'EscalationRule')
                {
                    obje.escalationRule = JSON.parse(updatedJsn);
                    tempJsn.EscalationRules = obje;
                }
                else if(metaType == 'MatchingRule')    
                {
                    obje.matchingRules = JSON.parse(updatedJsn);
                    tempJsn.MatchingRules = obje;
                }
                else if(metaType == 'ManagedTopic')
                {
                    obje.ManagedTopic = JSON.parse(updatedJsn);
                    tempJsn.ManagedTopics = obje;
                }

                oldXml = x2js.json2xml_str($.parseJSON(JSON.stringify(tempJsn)));
                oldXml = '<?xml version="1.0" encoding="UTF-8"?>'+oldXml;
            }
        }
        return oldXml;
    }
        
        
        
        function isMapNonEmpty(componentMetaMap)
        {
            if (componentMetaMap == undefined) return false;
            for(var key in componentMetaMap){
                return true;
            }
            return false;
        }
        
        var branchRef = '';
        var snapRef = '';
        
        function getCommitInformation(branchId,snapshotId,isSuccess, msg)
        {
            ComponentAttachmentWraperList = [];
            attList = [];
            fileMap = {};
            metaItemList = [];
            metaFoundMap = {};
            
            console.log('getCommitInformation='+branchId);
            ////console.log('branchId='+branchId);
            ////console.log('snapshotId='+snapshotId);
            ////console.log('isSuccess='+isSuccess);
            ////console.log('msg='+msg);
            branchRef = branchId;
            snapRef = snapshotId;
            
            if (isSuccess == true || isSuccess == 'true'){
                nSelected = getScope().initialSelectionSet0.length;
                if (nSelected > 0){ 
                    setMessageOnPage('Please wait...');
                    overridePageMessages();
                    ////console.log('selected:'+nSelected);
                    getScope().secondStageCommit();
                    return; 
                }else{
                    msg = 'Please select an item first.';
                }
            }
            console.log('msg---',msg);
            showErrorMessage(msg);
            hide();     
            return;
        }
        
        function overridePageMessages(){
            try{    
                var textureEffect = '';
                textureEffect = 'slds-theme--alert-texture';
                             
                $('.warningM3').addClass('slds-notify slds-notify--toast slds-theme--warning customMessage '+textureEffect);          
                $('.confirmM3').addClass('slds-notify slds-notify--alert slds-theme--success  customMessage '+textureEffect);    
                $('.errorM3').addClass('slds-notify slds-notify--alert slds-theme--error customMessage '+textureEffect);                  
                $('.infoM3').addClass('slds-notify slds-notify--toast customMessage '+textureEffect);                    
                $('.errorM3').removeClass('errorM3'); 
                $('.confirmM3').removeClass('confirmM3'); 
                $('.infoM3').removeClass('infoM3');   
                $('.warningM3').removeClass('warningM3');
            }
            catch(ex){
            }
        }
        
        function getSnapshotAttachmentsInfo(ids){
            console.log(ids);
            Visualforce.remoting.Manager.invokeAction(
                '{!$RemoteAction.OrgComponentToBranchCommitController.getSnapshotAttInfo}',
                 JSON.stringify(ids),
                 handleCommitInformation
            );
        }
        
        function handleCommitInformation(r,e)
        {
            console.log('handleCommitInformation=');
            if(e.status && r) 
            {
                console.log('r.attList.length'+r.attList.length);
                if(r.attList.length > 0)
                {
                    attList = [];
                    var bodySize = 0;
                    var temp = [];
                    for(var i in r.attList)
                    {
                        if(i< r.attList.length)
                        {
                            var att = r.attList[i];
                            console.log(att);
                            console.log(allCompTypeFilter);
                            
                            
                            //var validateDescription = typeToFolderMap[att.Description] != undefined ? typeToFolderMap[att.Description] : att.Description;
                            if (att.Description != undefined && allCompTypeFilter[att.Description] != undefined){
                                if(bodySize+att.BodyLength > 2000000 && temp.length > 0) 
                                {
                                    attList.push(temp);
                                    bodySize = 0;
                                    temp = [];
                                }
                                bodySize = bodySize+att.BodyLength;
                                temp.push(att.Id);
                            }
                        }
                    }
                    if(temp.length > 0)
                    {
                        attList.push(temp);
                    }
                    console.log('attList.length--'+attList.length);
                    if(attList.length > 0)
                    {
                        var attSet = attList.shift();
                        ////console.log('get attSet:'+attSet.length);
                        ////console.log('get attachments:'+JSON.stringify(attSet));
                        Visualforce.remoting.Manager.invokeAction(
                            '{!$RemoteAction.OrgComponentToBranchCommitController.getAttachments}',
                            JSON.stringify(attSet),
                            handleAttachments
                        );
                    }
                    else
                    {
                        showMessage('No attachments found.');
                    }
                }
                else
                {
                    showMessage('No attachments found.');
                }
            }
            else
            {
                showMessage(e.message);
            }
        }
        
        function getAttachments()
        {
            if(attList.length > 0)
            {
                var attSet = attList.shift();   
                    Visualforce.remoting.Manager.invokeAction(
                    '{!$RemoteAction.OrgComponentToBranchCommitController.getAttachments}',
                    JSON.stringify(attSet),
                    handleAttachments
                ); 
            }
        }
        
        var left_to_resolve = 0;
        
        function handleAttachments(r,e)
        {
            if(e.status && r)
            {
                console.log('got array of attachments:'+ r.length);
                var unpack = function(ar){
                    ////console.log( ' call- '+ar.length ); 
                    if(ar != undefined && ar.length > 0)
                    {
                        var arr = ar.shift();   
                        var componentType = arr.compType;
                        var zip = new JSZip(arr.base64, {base64:true});
                        ////console.log(componentType+ ' call- ');
                        left_to_resolve ++;
                        createFileMap(componentType, zip, function(res){
                            unpack(ar);
                        });
                    }else{
                        next();
                    }
                }
                unpack(r);
            }
            else
            {
                showMessage(e.message);
            }
        }
        
        function next(){
                if(attList.length > 0)
                {
                    getAttachments();
                }else{
                    //////console.log('all loaded');
                    if(true)
                    {
                        getScope().updateMetaData();
                    }
                    else
                    {
                        showMessage('No metadata items found.');
                    }
                }
        }
        
        
        
        function isFiltered(type, filename){
            if (filename == undefined) return false;
            if (revFolderMap[type] == undefined){ 
                if (filename.indexOf('-meta.xml') > -1){
                    filename = filename.slice(0,filename.indexOf('-meta.xml'));
                }
                return (allCompFilter[filename] != undefined);
            }else{
                if (filename.indexOf('-meta.xml') > -1){
                    var filename2 = filename.slice(0,filename.indexOf('-meta.xml'));
                    return (allCompFilter[filename] != undefined || allCompFilter[filename2] != undefined);
                }else{
                    return (allCompFilter[filename] != undefined);
                }
            }
        }
        
        function getAuraName(name){// aura/Test => Test,  aura/TestOne/onessd => Test
             if (name == undefined || name == '') return;
             if (name.indexOf('aura/') != 0 && name.indexOf('lwc/') != 0) return;
             if (name.lastIndexOf('/') > 5 && name.lastIndexOf('/') != (name.length - 1)){
                var fullName = name.slice(0,name.lastIndexOf('/'));
                ///console.log(name + '=>' + fullName);
                if (allCompFilter[fullName] != undefined){
                    return fullName;
                }
             }
            return;
        }
        
        // one-thread function
        function createFileMap(tempComponentType,tempZip,callback)
        {
            ////console.log('createFileMap for'+tempComponentType);
            if(tempComponentType == 'Profile' || tempComponentType == 'PermissionSet')
            {
                tempZip.remove('objects');
                tempZip.remove('classes');
                tempZip.remove('pages');
                tempZip.remove('layouts');
                tempZip.remove('tabs');
                tempZip.remove('applications');
                tempZip.remove('dataSources');
                tempZip.remove('customPermissions');
                for(var fileName in tempZip.files)
                {
                    if (isFiltered(tempComponentType,fileName) == false) continue;
                    if(fileName != undefined && (fileName.indexOf("profiles/") == 0 || fileName.indexOf("permissionsets/") == 0)) 
                    {
                        var fileData = tempZip.files[fileName].asBinary();
                        if(fileMap[tempComponentType+"#"+fileName] != undefined)
                        {
                            if(tempComponentType == 'Profile')
                                fileData = profileJoinOneByOne(unpack(fileMap[tempComponentType+"#"+fileName].data,true),fileData);
                            else if(tempComponentType == 'PermissionSet')
                                fileData = permissionSetJoinOneByOne(unpack(fileMap[tempComponentType+"#"+fileName].data,true),fileData);
                        }
                        fileMap[tempComponentType+"#"+fileName] = getCrcWithData(fileData,{compress:true});// Profile or PermissionSet
                    }
                }
                joinThreads(callback);
            }else if(bundleTypes[tempComponentType] != undefined){// process aura components
                for(var fileName in tempZip.files)
                {
                    var name = getAuraName(fileName);
                    if (name == undefined) continue;
                    //name = tempComponentType + '#' + name;
                    var descriptor = Object(); 
                    if (auraFileMap[name] != undefined){
                        descriptor = auraFileMap[name];
                    }
                    var fileData = tempZip.files[fileName].asBinary();
                    descriptor[fileName] = getCrcWithData(fileData);// any (incl. apex cls,pages,etc) except inners
                    auraFileMap[name] = descriptor;
                }
                joinThreads(callback);
            }else if(mmap[tempComponentType] == undefined){ 
                for(var fileName in tempZip.files)
                {
                    if (isFiltered(tempComponentType,fileName) == false) continue;
                    if(fileName != undefined && fileName.charAt(fileName.length - 1) != '/' && fileName != 'package.xml' && fileName != 'undefined') 
                    {
                        var fileData = tempZip.files[fileName].asBinary();
                        fileMap[tempComponentType+"#"+fileName] = getCrcWithData(fileData);// any (incl. apex cls,pages,etc) except inners
                    }
                }
                joinThreads(callback);
            }else{// process inner components
                var fileList = [];
                for(var fileName in tempZip.files)
                {
                    if (isFiltered(tempComponentType,fileName) == false) continue;
                    if(fileName != undefined && fileName.charAt(fileName.length - 1) != '/' && fileName != 'package.xml' && fileName != 'undefined') 
                    {
                        fileList.push(fileName);
                        getChildFileMap(tempComponentType,tempZip.files[fileName].asText(),fileName);//inner only
                    }
                }
                if (fileList.length > 0){
                    processInnerComponents(tempComponentType, fileList, tempZip.files, callback);
                }else{
                    joinThreads(callback);
                }
            }
        }

        // Joining threads, meaning that the callback only will
        // be performed when ALL parallel threads have executed
        function joinThreads(callback) {
            left_to_resolve--;
            if ((left_to_resolve == 0) && (callback !== null) && (callback != undefined)) {// call only if the thread is the last
                callback();
            }
        }
  
        
        function processInnerComponents(componentType, list, map, callback){
            if (list.length == 0){
                joinThreads(callback);
            }else{
                var fileName = list.shift();// get the 1st element
                getChildFileMap(componentType,map[fileName].asText(),fileName);
                setTimeout(function(){
                     processInnerComponents(componentType, list, map, callback);
                }, 5);
            } 
        }
        
        function getChildFileMap(metaType,xml,fileName)
        {
            var fullName = '';
            if(metaType != 'CustomLabel')
            {
                fullName = fileName.slice(fileName.indexOf("/")+1,fileName.lastIndexOf('.'))+".";
            }
    
            var x2js = new X2JS({useDoubleQuotes : true, stripWhitespaces : false, escapeMode: true});
            var jsnMap ={};
            var tempJSON = '';
            var srcjson = x2js.xml_str2json(xml);
            if(srcjson != undefined && srcjson != null)
            {
                var srcitems;
                if(metaType == 'CustomLabel')
                {
                    var srcMetaItem = srcjson.CustomLabels;
                    srcitems = srcMetaItem.labels;
                }
                else if(metaType == 'CustomField')
                {
                    var srcMetaItem = srcjson.CustomObject;
                    srcitems = srcMetaItem.fields;
                }
                else if(metaType == 'ListView')
                {
                    var srcMetaItem = srcjson.CustomObject;
                    srcitems = srcMetaItem.listViews;
                }
                else if(metaType == 'CompactLayout')
                {
                    var srcMetaItem = srcjson.CustomObject;
                    srcitems = srcMetaItem.compactLayouts;
                }
                else if(metaType == 'WebLink')
                {
                    var srcMetaItem = srcjson.CustomObject;
                    srcitems = srcMetaItem.webLinks;
                }
                else if(metaType == 'RecordType')
                {
                    var srcMetaItem = srcjson.CustomObject;
                    srcitems = srcMetaItem.recordTypes;
                }
                else if(metaType == 'FieldSet')
                {
                    var srcMetaItem = srcjson.CustomObject;
                    srcitems = srcMetaItem.fieldSets;
                }
                else if(metaType == 'ValidationRule')
                {
                    var srcMetaItem = srcjson.CustomObject;
                    srcitems = srcMetaItem.validationRules;
                }
                else if(metaType == 'AssignmentRule')
                {
                    var srcMetaItem = srcjson.AssignmentRules;
                    srcitems = srcMetaItem.assignmentRule;
                }
                else if(metaType == 'AutoResponseRule')
                {
                    var srcMetaItem = srcjson.AutoResponseRules;
                    srcitems = srcMetaItem.autoResponseRule;
                }
                else if(metaType == 'WorkflowTask')
                {
                    var srcMetaItem = srcjson.Workflow;
                    srcitems = srcMetaItem.tasks;
                }
                else if(metaType == 'WorkflowOutboundMessage')
                {
                    var srcMetaItem = srcjson.Workflow;
                    srcitems = srcMetaItem.outboundMessages;
                }
                else if(metaType == 'WorkflowFieldUpdate')
                {
                    var srcMetaItem = srcjson.Workflow;
                    srcitems = srcMetaItem.fieldUpdates;
                }
                else if(metaType == 'WorkflowKnowledgePublish')
                {
                    var srcMetaItem = srcjson.Workflow;
                    srcitems = srcMetaItem.knowledgePublishes;
                }
                else if(metaType == 'WorkflowAlert')
                {
                    var srcMetaItem = srcjson.Workflow;
                    srcitems = srcMetaItem.alerts;
                }
                else if( metaType == 'WorkflowRule')
                {
                    var srcMetaItem = srcjson.Workflow;
                    srcitems = srcMetaItem.rules;
                }
                else if(metaType == 'SharingCriteriaRule')
                {
                    var srcMetaItem = srcjson.SharingRules;
                    srcitems = srcMetaItem.sharingCriteriaRules;
                }
                else if(metaType == 'SharingOwnerRule')
                {
                    var srcMetaItem = srcjson.SharingRules;
                    srcitems = srcMetaItem.sharingOwnerRules;
                }
                else if(metaType == 'BusinessProcess')
                {
                    var srcMetaItem = srcjson.CustomObject;
                    srcitems = srcMetaItem.businessProcesses;
                }
                else if(metaType == 'SharingReason')
                {
                    var srcMetaItem = srcjson.CustomObject;
                    srcitems = srcMetaItem.sharingReasons;
                }
                else if(metaType == 'EscalationRule')
                {
                    var srcMetaItem = srcjson.EscalationRules;
                    srcitems = srcMetaItem.escalationRule;
                }
                else if(metaType == 'MatchingRule')    
                {
                    var srcMetaItem = srcjson.MatchingRules;
                    srcitems = srcMetaItem.matchingRules;
                }
                else if(metaType == 'ManagedTopic')
                {
                    var srcMetaItem = srcjson.ManagedTopics;
                    srcitems = srcMetaItem.ManagedTopic;
                }
                if(srcitems != undefined)
                {
                    if(srcitems.fullName == undefined)
                    {   
                        for(var i in srcitems)  
                        {
                            if(i < srcitems.length)
                            {
                                var v = srcitems[i];
                                jsnMap[v.fullName]= JSON.stringify(v);
                            }
                        }            
                    }
                    else
                    {
                        jsnMap[srcitems.fullName] = JSON.stringify(srcitems);
                    }
                }
            }
            for(var name in jsnMap)
            {
                var tempXml = '';
                var tempJSON = jsnMap[name];
                if(tempJSON != undefined)
                {
                    //header
                    if(metaType == 'CustomLabel')
                    {
                        tempXml = '<?xml version="1.0" encoding="UTF-8"?><CustomLabels xmlns="http://soap.sforce.com/2006/04/metadata">';
                    }
                    else if(metaType == 'AssignmentRule' )
                    {
                        tempXml = '<?xml version="1.0" encoding="UTF-8"?><AssignmentRules xmlns="http://soap.sforce.com/2006/04/metadata">';
                    }
                    else if(metaType == 'AutoResponseRule')
                    {
                        tempXml = '<?xml version="1.0" encoding="UTF-8"?><AutoResponseRules xmlns="http://soap.sforce.com/2006/04/metadata">';
                    }
                    else if(metaType == 'WorkflowAlert' || metaType == 'WorkflowFieldUpdate'|| metaType == 'WorkflowOutboundMessage'|| metaType == 'WorkflowTask' || metaType == 'WorkflowRule' || metaType == 'WorkflowKnowledgePublish')
                    {
                        tempXml = '<?xml version="1.0" encoding="UTF-8"?><Workflow xmlns="http://soap.sforce.com/2006/04/metadata">';
                    }
                    else if(metaType == 'SharingCriteriaRule' || metaType == 'SharingOwnerRule')
                    {
                        tempXml = '<?xml version="1.0" encoding="UTF-8"?><SharingRules xmlns="http://soap.sforce.com/2006/04/metadata">';
                    }
                    else if(metaType == 'EscalationRule')
                    {
                        tempXml = '<?xml version="1.0" encoding="UTF-8"?><EscalationRules xmlns="http://soap.sforce.com/2006/04/metadata">';
                    }
                    else if(metaType == 'MatchingRule')
                    {
                        tempXml = '<?xml version="1.0" encoding="UTF-8"?><MatchingRules xmlns="http://soap.sforce.com/2006/04/metadata">';
                    }
                    else if(metaType == 'ManagedTopic')
                    {
                        tempXml = '<?xml version="1.0" encoding="UTF-8"?><ManagedTopics xmlns="http://soap.sforce.com/2006/04/metadata">';
                    }
                    else
                    {
                        tempXml = '<?xml version="1.0" encoding="UTF-8"?><CustomObject xmlns="http://soap.sforce.com/2006/04/metadata">';
                    }
                    
                    //body
                    if(metaType == 'CustomLabel')
                    {
                        tempXml = tempXml +'<labels>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</labels>';
                    }
                    else if(metaType == 'CustomField')
                    {
                        tempXml = tempXml +'<fields>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</fields>';
                    }
                    else if(metaType == 'ListView')
                    {
                        tempXml = tempXml +'<listViews>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</listViews>';
                    }
                    else if(metaType == 'CompactLayout')
                    {
                        tempXml = tempXml +'<compactLayouts>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</compactLayouts>';
                    }
                    else if(metaType == 'WebLink')
                    {
                        tempXml = tempXml +'<webLinks>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</webLinks>';
                    }
                    else if(metaType == 'RecordType')
                    {
                        tempXml = tempXml +'<recordTypes>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</recordTypes>';
                    }
                    else if(metaType == 'FieldSet')
                    {
                        tempXml = tempXml +'<fieldSets>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</fieldSets>';
                    }
                    else if(metaType == 'ValidationRule')
                    {
                        tempXml = tempXml +'<validationRules>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</validationRules>';
                    }
                    else if(metaType == 'AssignmentRule')
                    {
                        tempXml = tempXml +'<assignmentRule>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</assignmentRule>';
                    }
                    else if(metaType == 'AutoResponseRule')
                    {
                        tempXml = tempXml +'<autoResponseRule>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</autoResponseRule>';
                    }
                    else if(metaType == 'WorkflowAlert')
                    {
                        tempXml = tempXml +'<alerts>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</alerts>';
                    }
                    else if(metaType == 'WorkflowFieldUpdate')
                    {
                        tempXml = tempXml +'<fieldUpdates>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</fieldUpdates>';
                    }
                    else if(metaType == 'WorkflowKnowledgePublish')
                    {
                        tempXml = tempXml +'<knowledgePublishes>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</knowledgePublishes>';
                    }
                    else if(metaType == 'WorkflowOutboundMessage')
                    {
                        tempXml = tempXml +'<outboundMessages>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</outboundMessages>';
                    }
                    else if(metaType == 'WorkflowTask')
                    {
                        tempXml = tempXml +'<tasks>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</tasks>';
                    }
                    else if(metaType == 'WorkflowRule')
                    {
                        tempXml = tempXml +'<rules>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</rules>';
                    }
                    else if(metaType == 'SharingCriteriaRule')
                    {
                        tempXml = tempXml +'<sharingCriteriaRules>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</sharingCriteriaRules>';
                    }
                    else if(metaType == 'SharingOwnerRule')
                    {
                        tempXml = tempXml +'<sharingOwnerRules>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</sharingOwnerRules>';
                    }
                    else if(metaType == 'EscalationRule')
                    {
                        tempXml = tempXml +'<escalationRule>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</escalationRule>';
                    }
                    else if(metaType == 'MatchingRule')
                    {
                        tempXml = tempXml +'<matchingRules>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</matchingRules>';
                    }
                    else if(metaType == 'ManagedTopic')
                    {
                        tempXml = tempXml +'<managedTopic>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</managedTopic>';
                    }
                    else if(metaType == 'BusinessProcess')
                    {
                        tempXml = tempXml +'<businessProcesses>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</businessProcesses>';
                    }
                    else if(metaType == 'SharingReason')
                    {
                        tempXml = tempXml +'<sharingReasons>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</sharingReasons>';
                    }
                    
                    
                    //footer
                    if(metaType == 'CustomLabel')
                    {
                        tempXml = tempXml +'</CustomLabels>';
                    }
                    else if(metaType == 'AssignmentRule' )
                    {
                        tempXml = tempXml +'</AssignmentRules>';
                    }
                    else if(metaType == 'AutoResponseRule')
                    {
                        tempXml = tempXml +'</AutoResponseRules>';
                    }
                    else if(metaType == 'WorkflowAlert' || metaType == 'WorkflowFieldUpdate'|| metaType == 'WorkflowOutboundMessage'|| metaType == 'WorkflowTask' || metaType == 'WorkflowRule' || metaType == 'WorkflowKnowledgePublish')
                    {
                        tempXml = tempXml +'</Workflow>';
                    }
                    else if(metaType == 'SharingCriteriaRule' || metaType == 'SharingOwnerRule')
                    {
                        tempXml = tempXml +'</SharingRules>';
                    }
                    else if(metaType == 'EscalationRule')
                    {
                        tempXml = tempXml +'</EscalationRules>';
                    }
                    else if(metaType == 'MatchingRule')
                    {
                        tempXml = tempXml +'</MatchingRules>';
                    }
                    else if(metaType == 'ManagedTopic')
                    {
                        tempXml = tempXml +'</ManagedTopics>';
                    }
                    else
                    {
                        tempXml = tempXml +'</CustomObject>';
                    }
//                  tempXml = unescape(encodeURIComponent(tempXml));
                    fileMap[metaType+"#"+fullName+""+name]= getCrcWithData(tempXml,{isInnerType:true});
                }
            }
        }
        
        const XML_HEADER = '<?xml version="1.0" encoding="UTF-8"?>';
        function getCrcWithData(zipData,flags)
        {
            var r = new Object();
            if (zipData != undefined && flags != undefined && flags.isInnerType == true){
                zipData = vkbeautify.xml(zipData);
            }
            r.crc32 = normalZip.crc32(zipData,32);
            if (flags != undefined && flags.compress == true){
                r.data = pako.deflate(zipData, { to: 'string' });
            }else{
                r.data = zipData;
            }
            return r;
        }
        
         
        function profileJoinOneByOne(oldProfileXML,newProfileXML) 
        {
            var x2js = new X2JS({useDoubleQuotes : true, stripWhitespaces : false, escapeMode: true});
            var oldJSN = x2js.xml_str2json(oldProfileXML);
            var newJSN = x2js.xml_str2json(newProfileXML);
            if(newJSN.Profile != undefined && oldJSN.Profile != undefined)
            {
                srcjson = newJSN.Profile;
                var profile = oldJSN.Profile;
                
                if(srcjson._xmlns != undefined)
                {
                    profile._xmlns = srcjson._xmlns;
                }
                if(srcjson.applicationVisibilities != undefined)
                {
                    profile.applicationVisibilities = srcjson.applicationVisibilities;
                }
                if(srcjson.classAccesses != undefined)
                {
                    profile.classAccesses = srcjson.classAccesses;
                }
                if(srcjson.custom != undefined)
                {
                    profile.custom = srcjson.custom;
                }
                if(srcjson.customPermissions != undefined)
                {
                    profile.customPermissions = srcjson.customPermissions;
                }
                if(srcjson.description != undefined)
                {
                    profile.description = srcjson.description;
                }
                if(srcjson.externalDataSourceAccesses != undefined)
                {
                    profile.externalDataSourceAccesses = srcjson.externalDataSourceAccesses;
                }
                if(srcjson.fieldLevelSecurities != undefined)
                {
                    profile.fieldLevelSecurities = srcjson.fieldLevelSecurities;
                }
                if(srcjson.fieldPermissions != undefined)
                {
                    profile.fieldPermissions = srcjson.fieldPermissions;
                }
                if(srcjson.fullName != undefined)
                {
                    profile.fullName = srcjson.fullName;
                }
                if(srcjson.layoutAssignments != undefined)
                {
                    profile.layoutAssignments = srcjson.layoutAssignments;
                }
                if(srcjson.loginHours != undefined)
                {
                    profile.loginHours = srcjson.loginHours;
                }
                if(srcjson.loginIpRanges != undefined)
                {
                    profile.loginIpRanges = srcjson.loginIpRanges;
                }
                if(srcjson.objectPermissions != undefined)
                {
                    profile.objectPermissions = srcjson.objectPermissions;
                }
                if(srcjson.pageAccesses != undefined)
                {
                    profile.pageAccesses = srcjson.pageAccesses;
                }
                if(srcjson.recordTypeVisibilities != undefined)
                {
                    profile.recordTypeVisibilities = srcjson.recordTypeVisibilities;
                }
                if(srcjson.tabVisibilities != undefined)
                {
                    profile.tabVisibilities = srcjson.tabVisibilities;
                }
                if(srcjson.userLicense != undefined)
                {
                    profile.userLicense = srcjson.userLicense;
                }
                if(srcjson.userPermissions != undefined)
                {
                    profile.userPermissions = srcjson.userPermissions;
                }
                oldJSN.Profile = profile;
            }
            fullXML = x2js.json2xml_str(oldJSN);
//          fullXML = unescape(encodeURIComponent(fullXML));

            return fullXML;
        }
        
        function permissionSetJoinOneByOne(oldPermissionSetXML,newPermissionSetXML) 
        {
            var x2js = new X2JS({useDoubleQuotes : true, stripWhitespaces : false, escapeMode: true});
            var oldJSN = x2js.xml_str2json(oldPermissionSetXML);
            var newJSN = x2js.xml_str2json(newPermissionSetXML);
            if(newJSN.PermissionSet != undefined && oldJSN.PermissionSet != undefined)
            {
                srcjson = newJSN.PermissionSet;
                var perm = oldJSN.PermissionSet;
                
                if(srcjson._xmlns != undefined)
                {
                    perm._xmlns = srcjson._xmlns;
                }
                if(srcjson.applicationVisibilities != undefined)
                {
                    perm.applicationVisibilities = srcjson.applicationVisibilities;
                }
                if(srcjson.classAccesses != undefined)
                {
                    perm.classAccesses = srcjson.classAccesses;
                }
                if(srcjson.customPermissions != undefined)
                {
                    perm.customPermissions = srcjson.customPermissions;
                }
                if(srcjson.description != undefined)
                {
                    perm.description = srcjson.description;
                }
                if(srcjson.externalDataSourceAccesses != undefined)
                {
                    perm.externalDataSourceAccesses = srcjson.externalDataSourceAccesses;
                }
                if(srcjson.fieldLevelSecurities != undefined)
                {
                    perm.fieldLevelSecurities = srcjson.fieldLevelSecurities;
                }
                if(srcjson.fieldPermissions != undefined)
                {
                    perm.fieldPermissions = srcjson.fieldPermissions;
                }
                if(srcjson.label != undefined)
                {
                    perm.label = srcjson.label;
                }
                if(srcjson.objectPermissions != undefined)
                {
                    perm.objectPermissions = srcjson.objectPermissions;
                }
                if(srcjson.pageAccesses != undefined)
                {
                    perm.pageAccesses = srcjson.pageAccesses;
                }
                if(srcjson.recordTypeVisibilities != undefined)
                {
                    perm.recordTypeVisibilities = srcjson.recordTypeVisibilities;
                }
                if(srcjson.tabSettings != undefined)
                {
                    perm.tabSettings = srcjson.tabSettings;
                }
                if(srcjson.userLicense != undefined)
                {
                    perm.userLicense = srcjson.userLicense;
                }
                if(srcjson.userPermissions != undefined)
                {
                    perm.userPermissions = srcjson.userPermissions;
                }
                oldJSN.PermissionSet = perm;
            }
            fullXML = x2js.json2xml_str(oldJSN);
//          fullXML = unescape(encodeURIComponent(fullXML));
            return fullXML;
        }
        
        function setAll(array,isAllChecked){
                    for(var index = 0; index < array.length; index++) {
                        if(isAllChecked)
                            array[index].check = true;
                        else
                            array[index].check = false;  
                    }
        }
        


    </script>
</apex:page>